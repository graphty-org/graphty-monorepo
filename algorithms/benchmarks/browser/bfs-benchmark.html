<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>BFS Browser Performance Benchmark</title>
        <style>
            body {
                font-family: "Courier New", monospace;
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
                background-color: #1e1e1e;
                color: #d4d4d4;
            }
            .header {
                text-align: center;
                margin-bottom: 30px;
                padding: 20px;
                background-color: #2d2d30;
                border-radius: 8px;
            }
            .console {
                background-color: #0c0c0c;
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                padding: 15px;
                height: 400px;
                overflow-y: auto;
                margin-bottom: 20px;
                font-family: "Courier New", monospace;
                font-size: 12px;
                line-height: 1.4;
            }
            .controls {
                text-align: center;
                margin-bottom: 20px;
            }
            button {
                background-color: #0e639c;
                color: white;
                border: none;
                padding: 10px 20px;
                margin: 0 10px;
                border-radius: 4px;
                cursor: pointer;
                font-family: inherit;
            }
            button:hover {
                background-color: #1177bb;
            }
            button:disabled {
                background-color: #666;
                cursor: not-allowed;
            }
            .results {
                background-color: #2d2d30;
                padding: 15px;
                border-radius: 8px;
                margin-top: 20px;
            }
            .system-info {
                background-color: #2d2d30;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>üöÄ BFS Browser Performance Benchmark</h1>
            <p>Cross-platform graph algorithm performance testing using Benchmark.js</p>
        </div>

        <div class="system-info">
            <h3>System Information</h3>
            <div id="systemInfo">Loading...</div>
        </div>

        <div class="controls">
            <button id="quickBtn" onclick="runBenchmark('quick')">Run Quick Tests (~30s)</button>
            <button id="comprehensiveBtn" onclick="runBenchmark('comprehensive')">
                Run Comprehensive Tests (~5min)
            </button>
            <button id="clearBtn" onclick="clearConsole()">Clear Console</button>
            <button id="downloadBtn" onclick="downloadResults()" disabled>Download Results</button>
        </div>

        <div class="console" id="console"></div>

        <div class="results" id="results" style="display: none">
            <h3>Results Summary</h3>
            <div id="resultsSummary"></div>
        </div>

        <!-- Load Benchmark.js from CDN -->
        <script src="https://cdn.jsdelivr.net/npm/benchmark@2.1.4/benchmark.min.js"></script>

        <!-- Load the compiled graph algorithms -->
        <script type="module">
            // This would be your compiled graph algorithms
            // For demo purposes, we'll create a simple BFS implementation

            // Simple Graph implementation for demo
            class SimpleGraph {
                constructor(vertices) {
                    this.vertices = vertices;
                    this.adjacencyList = {};
                    for (let i = 0; i < vertices; i++) {
                        this.adjacencyList[i] = [];
                    }
                }

                addEdge(from, to) {
                    this.adjacencyList[from].push(to);
                    this.adjacencyList[to].push(from);
                }

                hasNode(node) {
                    return node >= 0 && node < this.vertices;
                }

                getNeighbors(node) {
                    return this.adjacencyList[node] || [];
                }
            }

            // Simple BFS implementation for demo
            function breadthFirstSearch(graph, startNode) {
                if (!graph.hasNode(startNode)) {
                    throw new Error(`Start node ${startNode} not found in graph`);
                }

                const visited = new Set();
                const queue = [startNode];
                const order = [];

                visited.add(startNode);

                while (queue.length > 0) {
                    const node = queue.shift();
                    order.push(node);

                    for (const neighbor of graph.getNeighbors(node)) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    }
                }

                return {
                    visited,
                    order,
                    tree: new Map(), // Simplified
                };
            }

            // Graph generators for demo
            function generateSparseGraph(vertices) {
                const graph = new SimpleGraph(vertices);
                const avgDegree = 6;
                const numEdges = Math.floor((vertices * avgDegree) / 2);

                for (let i = 0; i < numEdges; i++) {
                    const from = Math.floor(Math.random() * vertices);
                    const to = Math.floor(Math.random() * vertices);
                    if (from !== to) {
                        graph.addEdge(from, to);
                    }
                }

                return { graph, edges: numEdges };
            }

            // System info collection
            function getSystemInfo() {
                const nav = navigator;
                const screen = window.screen;
                const performance = window.performance;

                return {
                    platform: nav.platform,
                    userAgent: nav.userAgent,
                    language: nav.language,
                    hardwareConcurrency: nav.hardwareConcurrency || "unknown",
                    screen: `${screen.width}x${screen.height}`,
                    devicePixelRatio: window.devicePixelRatio,
                    memory: performance.memory
                        ? {
                              usedJSHeapSize: performance.memory.usedJSHeapSize,
                              totalJSHeapSize: performance.memory.totalJSHeapSize,
                              jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                          }
                        : "not available",
                    timestamp: new Date().toISOString(),
                };
            }

            // Console logging
            function log(message) {
                const console = document.getElementById("console");
                const time = new Date().toLocaleTimeString();
                console.innerHTML += `<div>[${time}] ${message}</div>`;
                console.scrollTop = console.scrollHeight;
            }

            function clearConsole() {
                document.getElementById("console").innerHTML = "";
            }

            let currentResults = null;

            // Warmup function for browser benchmarks
            async function performWarmup(name, testFn, warmupConfig) {
                if (!warmupConfig?.enabled) {
                    return;
                }

                log(`  Warming up ${name}...`);
                const startTime = Date.now();
                const minTimeMs = (warmupConfig.minTime || 0.1) * 1000;

                // Run warmup iterations
                for (let i = 0; i < warmupConfig.iterations; i++) {
                    try {
                        testFn();
                    } catch (error) {
                        log(`  Warmup iteration ${i + 1} failed: ${error.message}`);
                    }
                }

                // Ensure minimum warmup time
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime < minTimeMs) {
                    const remainingTime = minTimeMs - elapsedTime;
                    log(`  Extending warmup for ${remainingTime}ms...`);

                    const additionalStart = Date.now();
                    while (Date.now() - additionalStart < remainingTime) {
                        try {
                            testFn();
                        } catch (error) {
                            // Continue warmup despite errors
                        }
                    }
                }

                // Force garbage collection after warmup if available
                if (window.gc) {
                    window.gc();
                }
                log(`  Warmup completed for ${name}`);
            }

            // Benchmark configurations
            const configs = {
                quick: {
                    testType: "quick",
                    platform: "browser",
                    sizes: [100, 500, 2000],
                    iterations: 5,
                    warmup: {
                        enabled: true,
                        iterations: 3,
                        minTime: 0.05, // 50ms minimum warmup
                    },
                },
                comprehensive: {
                    testType: "comprehensive",
                    platform: "browser",
                    sizes: [100, 500, 2000, 5000],
                    iterations: 10,
                    warmup: {
                        enabled: true,
                        iterations: 5,
                        minTime: 0.1, // 100ms minimum warmup
                    },
                },
            };

            // Main benchmark function
            async function runBenchmark(configType) {
                const config = configs[configType];
                const buttons = document.querySelectorAll("button");
                buttons.forEach((btn) => (btn.disabled = true));

                log(`üöÄ Starting ${configType} BFS benchmarks in browser`);
                log("=" + "=".repeat(50));

                // Display system info
                const sysInfo = getSystemInfo();
                log(`Platform: ${sysInfo.platform}`);
                log(`CPU Cores: ${sysInfo.hardwareConcurrency}`);
                log(`Screen: ${sysInfo.screen}`);
                log("");

                // Pre-generate test graphs
                log("Pre-generating test graphs...");
                const testGraphs = new Map();

                for (const size of config.sizes) {
                    try {
                        log(`  Generating ${size} vertex sparse graph...`);
                        const { graph, edges } = generateSparseGraph(size);
                        testGraphs.set(`sparse-${size}`, {
                            graph,
                            edges,
                            size,
                            type: "sparse",
                        });
                        log(`    ‚úì ${size} vertices, ~${edges} edges`);
                    } catch (error) {
                        log(`    ‚úó Failed to generate ${size} vertex graph: ${error.message}`);
                    }
                }

                // Create benchmark suite
                const suite = new Benchmark.Suite(`BFS ${configType} Performance`);
                const results = [];

                // Add benchmark tests
                log("\nAdding benchmark tests...");
                const testFunctions = new Map();
                for (const size of config.sizes) {
                    const testKey = `sparse-${size}`;
                    if (testGraphs.has(testKey)) {
                        const testData = testGraphs.get(testKey);
                        const testName = `BFS ${size} vertices (sparse)`;
                        const testFn = function () {
                            const result = breadthFirstSearch(testData.graph, 0);
                            if (result.visited.size === 0) {
                                throw new Error("BFS returned empty result");
                            }
                        };

                        testFunctions.set(testName, testFn);

                        suite.add(testName, testFn, {
                            minSamples: config.iterations,
                            setup: function () {
                                // Browser GC hint (if available)
                                if (window.gc) {
                                    window.gc();
                                }
                            },
                        });
                    }
                }

                // Perform warmup if enabled
                if (config.warmup?.enabled) {
                    log("\nStarting warmup phase...");
                    for (const [testName, testFn] of testFunctions) {
                        await performWarmup(testName, testFn, config.warmup);
                    }
                    log("Warmup phase completed. Starting benchmarks...\n");
                }

                // Run benchmarks
                log(`Running ${configType} benchmarks...\n`);

                return new Promise((resolve) => {
                    suite
                        .on("cycle", function (event) {
                            const benchmark = event.target;
                            const size = parseInt(benchmark.name.match(/BFS (\d+) vertices/)[1]);
                            const testData = testGraphs.get(`sparse-${size}`);

                            const result = {
                                algorithm: "BFS",
                                graphType: "sparse",
                                graphSize: size,
                                edges: testData.edges,
                                executionTime: benchmark.stats.mean * 1000, // Convert to ms
                                opsPerSecond: benchmark.hz,
                                marginOfError: benchmark.stats.rme,
                                samples: benchmark.stats.sample.length,
                                platform: "browser",
                                testType: configType,
                                timestamp: new Date().toISOString(),
                            };

                            results.push(result);
                            log(`  ${benchmark.name}: ${benchmark.toString()}`);
                        })
                        .on("complete", function () {
                            log("\n" + "=".repeat(60));
                            log("BENCHMARK RESULTS SUMMARY");
                            log("=".repeat(60));
                            log("Size\tTime(ms)\tOps/sec\tMargin");
                            log("-".repeat(40));

                            results.forEach((result) => {
                                log(
                                    `${result.graphSize}\t${result.executionTime.toFixed(2)}\t\t${result.opsPerSecond.toFixed(0)}\t¬±${result.marginOfError.toFixed(1)}%`,
                                );
                            });

                            currentResults = {
                                sessionId: Math.random().toString(36).substring(7),
                                timestamp: new Date().toISOString(),
                                systemInfo: sysInfo,
                                testType: configType,
                                results: results,
                            };

                            log(`\n‚úÖ Benchmark completed successfully!`);

                            // Enable download button
                            document.getElementById("downloadBtn").disabled = false;

                            // Show results summary
                            displayResults(results);

                            // Re-enable buttons
                            buttons.forEach((btn) => (btn.disabled = false));

                            resolve(currentResults);
                        })
                        .on("error", function (error) {
                            log(`‚ùå Benchmark failed: ${error.message}`);
                            buttons.forEach((btn) => (btn.disabled = false));
                        })
                        .run({ async: true });
                });
            }

            function displayResults(results) {
                const resultsDiv = document.getElementById("results");
                const summaryDiv = document.getElementById("resultsSummary");

                let html = '<table border="1" style="width: 100%; border-collapse: collapse;">';
                html += "<tr><th>Size</th><th>Time (ms)</th><th>Ops/sec</th><th>Margin</th></tr>";

                results.forEach((result) => {
                    html += `<tr>
                    <td>${result.graphSize}</td>
                    <td>${result.executionTime.toFixed(2)}</td>
                    <td>${result.opsPerSecond.toFixed(0)}</td>
                    <td>¬±${result.marginOfError.toFixed(1)}%</td>
                </tr>`;
                });

                html += "</table>";
                summaryDiv.innerHTML = html;
                resultsDiv.style.display = "block";
            }

            function downloadResults() {
                if (!currentResults) return;

                const dataStr = JSON.stringify(currentResults, null, 2);
                const dataBlob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement("a");
                link.href = url;
                link.download = `browser-benchmark-${currentResults.testType}-${new Date().toISOString().split("T")[0]}.json`;
                link.click();

                URL.revokeObjectURL(url);
                log("üìÅ Results downloaded successfully!");
            }

            // Initialize system info display
            document.addEventListener("DOMContentLoaded", function () {
                const sysInfo = getSystemInfo();
                const systemInfoDiv = document.getElementById("systemInfo");
                systemInfoDiv.innerHTML = `
                <strong>Platform:</strong> ${sysInfo.platform}<br>
                <strong>User Agent:</strong> ${sysInfo.userAgent}<br>
                <strong>CPU Cores:</strong> ${sysInfo.hardwareConcurrency}<br>
                <strong>Screen:</strong> ${sysInfo.screen}<br>
                <strong>Device Pixel Ratio:</strong> ${sysInfo.devicePixelRatio}<br>
                <strong>Memory:</strong> ${
                    typeof sysInfo.memory === "object"
                        ? `${(sysInfo.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB used`
                        : sysInfo.memory
                }
            `;
            });

            // Make functions globally available
            window.runBenchmark = runBenchmark;
            window.clearConsole = clearConsole;
            window.downloadResults = downloadResults;
        </script>
    </body>
</html>
