<!doctype html>
<html lang="en">
    <head>
        <!-- MANDATORY: Eruda Mobile Console (exact code) -->
        <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
        <script>
            if (typeof eruda !== "undefined") {
                eruda.init();
                if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
                    eruda.show();
                }
            }
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HITS Algorithm - Simple Visual Explanation</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
        <style>
            /* MANDATORY STYLES - DO NOT MODIFY */
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background: #f5f5f5; /* Light gray background */
            }

            h1 {
                color: #2c5aa0; /* Blue header */
                text-align: center;
            }

            .container {
                background: white;
                border-radius: 8px;
                padding: 30px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            #graph {
                width: 100%;
                height: 400px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                margin: 20px 0;
            }

            button {
                background: #4caf50; /* Green button */
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 6px;
                cursor: pointer;
            }

            .explanation {
                background: #e8f0fe;
                border-left: 4px solid #2c5aa0;
                padding: 15px;
                margin: 20px 0;
                border-radius: 4px;
            }

            /* Additional algorithm-specific styles */
            .back-link {
                text-decoration: none;
                color: #2c5aa0;
                display: inline-block;
                margin-bottom: 20px;
                font-weight: 500;
            }

            .back-link:hover {
                text-decoration: underline;
            }

            .intro {
                margin-bottom: 20px;
            }

            .intro p {
                margin: 10px 0;
                line-height: 1.6;
            }

            .intro strong {
                color: #333;
            }

            .hits-info {
                display: flex;
                justify-content: space-around;
                margin: 20px 0;
                background: #f8f9fa;
                padding: 15px;
                border-radius: 6px;
                flex-wrap: wrap;
                gap: 15px;
            }

            .hits-stat {
                text-align: center;
                flex: 1;
                min-width: 100px;
            }

            .hits-stat .value {
                font-size: 20px;
                font-weight: bold;
                color: #2c5aa0;
            }

            .hits-stat .label {
                font-size: 11px;
                color: #666;
                margin-top: 5px;
            }

            .step-info {
                margin: 20px 0;
                padding: 15px;
                background: #f0f7ff;
                border-radius: 6px;
                font-size: 16px;
                text-align: center;
            }

            .legend {
                display: flex;
                gap: 15px;
                flex-wrap: wrap;
                margin-top: 15px;
                padding: 10px;
                background: #f8f9fa;
                border-radius: 6px;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .legend-color {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid #333;
            }

            button:hover {
                background: #45a049;
            }

            button:disabled {
                background: #ccc;
                cursor: not-allowed;
            }

            .controls {
                text-align: center;
                margin: 20px 0;
            }

            .algorithm-settings {
                display: flex;
                gap: 20px;
                margin: 20px 0;
                flex-wrap: wrap;
                justify-content: center;
            }

            .setting-group {
                display: flex;
                flex-direction: column;
                gap: 5px;
                align-items: center;
            }

            .setting-group label {
                font-size: 14px;
                color: #666;
            }

            .setting-group input[type="range"] {
                width: 120px;
            }

            .setting-group span {
                font-weight: bold;
                color: #2c5aa0;
                font-size: 12px;
            }

            .explanation h3 {
                color: #2c5aa0;
                margin-top: 0;
            }

            .code-section {
                margin-top: 30px;
                border-top: 1px solid #e0e0e0;
                padding-top: 20px;
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .code-header h3 {
                margin: 0;
                color: #2c5aa0;
            }

            .code-toggle {
                background: none;
                border: 1px solid #2c5aa0;
                color: #2c5aa0;
                padding: 6px 12px;
                font-size: 14px;
                cursor: pointer;
                border-radius: 4px;
            }

            .code-toggle:hover {
                background: #2c5aa0;
                color: white;
            }

            .code-content {
                background: #f8f9fa;
                border-radius: 6px;
                overflow: hidden;
                transition: max-height 0.3s ease;
            }

            .code-content.collapsed {
                max-height: 0;
            }

            pre {
                margin: 0;
                overflow-x: auto;
            }

            text {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            }

            /* Node styling */
            .node-text {
                font-size: 12px;
                font-weight: bold;
                fill: white;
                text-anchor: middle;
                dominant-baseline: central;
            }

            .score-text {
                font-size: 9px;
                fill: #333;
                text-anchor: middle;
                dominant-baseline: central;
            }

            .hub-score {
                fill: #e91e63;
            }

            .auth-score {
                fill: #3f51b5;
            }

            .iteration-info {
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                border-radius: 6px;
                padding: 10px;
                margin: 10px 0;
                font-size: 14px;
                text-align: center;
            }

            .view-toggle {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin: 20px 0;
            }

            .view-btn {
                background: #e0e0e0;
                color: #333;
                border: none;
                padding: 8px 16px;
                font-size: 14px;
                border-radius: 4px;
                cursor: pointer;
            }

            .view-btn.active {
                background: #2c5aa0;
                color: white;
            }

            .view-btn:hover {
                background: #2c5aa0;
                color: white;
            }

            /* Arrow styles */
            .arrow {
                marker-end: url(#arrowhead);
            }

            .node-border {
                stroke-width: 3;
            }
        </style>
    </head>
    <body>
        <a href="../../index.html" class="back-link">← Back to Examples</a>

        <h1>HITS Algorithm Explained</h1>

        <div class="container">
            <div class="intro">
                <p>
                    <strong
                        >Like a popularity contest with two awards - Best Pointer (Hub) and Most Pointed-To
                        (Authority)!</strong
                    >
                </p>
                <p>
                    HITS finds both hub nodes (that point to many valuable pages) and authority nodes (that are pointed
                    to by many hubs). It's like Google's PageRank but with two separate scores.
                </p>
            </div>

            <svg id="graph">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
                    </marker>
                </defs>
            </svg>

            <div class="view-toggle">
                <button class="view-btn active" id="view-hubs" onclick="setView('hubs')">Hub Scores</button>
                <button class="view-btn" id="view-authorities" onclick="setView('authorities')">
                    Authority Scores
                </button>
                <button class="view-btn" id="view-combined" onclick="setView('combined')">Combined View</button>
            </div>

            <div class="hits-info">
                <div class="hits-stat">
                    <div class="value" id="top-hub">-</div>
                    <div class="label">Top Hub</div>
                </div>
                <div class="hits-stat">
                    <div class="value" id="top-authority">-</div>
                    <div class="label">Top Authority</div>
                </div>
                <div class="hits-stat">
                    <div class="value" id="iterations-count">0</div>
                    <div class="label">Iterations</div>
                </div>
                <div class="hits-stat">
                    <div class="value" id="convergence-status">-</div>
                    <div class="label">Status</div>
                </div>
            </div>

            <div class="iteration-info" id="iteration-info" style="display: none">
                Iteration <span id="current-iteration">0</span>: <span id="iteration-step">Computing scores...</span>
            </div>

            <div class="step-info" id="step-info">Click "Start" to see how HITS works</div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #e91e63"></div>
                    <span>High Hub Score</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3f51b5"></div>
                    <span>High Authority Score</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9c27b0"></div>
                    <span>High Both Scores</span>
                </div>
            </div>

            <div class="algorithm-settings">
                <div class="setting-group">
                    <label for="animation-speed">Animation Speed</label>
                    <input type="range" id="animation-speed" min="500" max="3000" value="1500" step="100" />
                    <span id="speed-value">1.5s</span>
                </div>
            </div>

            <div class="controls">
                <button id="start-btn" onclick="startAlgorithm()">Start HITS Algorithm</button>
            </div>

            <div class="explanation">
                <h3>Key Concept:</h3>
                <p>
                    HITS solves a mutual reinforcement problem: good hubs point to good authorities, and good
                    authorities are pointed to by good hubs. The algorithm iteratively updates both scores until they
                    stabilize.
                </p>
                <p><strong>Hub Score:</strong> Sum of authority scores of nodes you point to</p>
                <p><strong>Authority Score:</strong> Sum of hub scores of nodes pointing to you</p>
                <p>
                    Originally designed for web search, it's perfect for finding influential connectors and respected
                    experts in any network.
                </p>
            </div>

            <div class="code-section">
                <div class="code-header">
                    <h3>Code Example</h3>
                    <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
                </div>
                <div class="code-content" id="code-content">
                    <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

        <script type="module">
            // Import the algorithm functions
            import { Graph } from "./algorithms.js";
            import { hits } from "./algorithms.js";

            // Load and display the actual code
            async function loadCodeExample() {
                try {
                    const response = await fetch("./hits.js");
                    const code = await response.text();
                    document.getElementById("code-display").textContent = code;
                    Prism.highlightElement(document.getElementById("code-display"));
                } catch (error) {
                    document.getElementById("code-display").textContent =
                        `import { Graph, hits } from '@graphty/algorithms';

// Create a directed graph
const graph = new Graph({ directed: true });

// Add nodes
graph.addNode('A'); // Hub
graph.addNode('B'); // Authority
graph.addNode('C'); // Authority
graph.addNode('D'); // Hub
graph.addNode('E'); // Authority

// Add directed edges (A and D are hubs pointing to authorities)
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('A', 'E');
graph.addEdge('D', 'B');
graph.addEdge('D', 'C');

// Calculate HITS scores
const result = hits(graph, {
    maxIterations: 100,
    tolerance: 1e-6
});

console.log('Hub scores:', result.hubs);
console.log('Authority scores:', result.authorities);`;
                    Prism.highlightElement(document.getElementById("code-display"));
                }
            }

            // Graph structure for visualization - web-like structure
            const nodes = [
                { id: "A", x: 150, y: 100, type: "hub" }, // Hub node
                { id: "B", x: 100, y: 250, type: "auth" }, // Authority
                { id: "C", x: 200, y: 250, type: "auth" }, // Authority
                { id: "D", x: 300, y: 250, type: "auth" }, // Authority
                { id: "E", x: 450, y: 100, type: "hub" }, // Another hub
                { id: "F", x: 400, y: 250, type: "auth" }, // Authority
                { id: "G", x: 500, y: 250, type: "auth" }, // Authority
                { id: "H", x: 350, y: 350, type: "mixed" }, // Mixed node
            ];

            const edges = [
                // A is a hub pointing to authorities
                { source: "A", target: "B" },
                { source: "A", target: "C" },
                { source: "A", target: "D" },

                // E is another hub
                { source: "E", target: "D" },
                { source: "E", target: "F" },
                { source: "E", target: "G" },

                // Some cross-links
                { source: "B", target: "H" },
                { source: "C", target: "H" },
                { source: "H", target: "F" },
                { source: "H", target: "G" },
            ];

            // Create graph for algorithm
            function createGraph() {
                const graph = new Graph({ directed: true });

                // Add nodes
                nodes.forEach((node) => graph.addNode(node.id));

                // Add edges
                edges.forEach((edge) => graph.addEdge(edge.source, edge.target));

                return graph;
            }

            // Animation state
            let isAnimating = false;
            let hubScores = new Map();
            let authorityScores = new Map();
            let animationSpeed = 1500;
            let currentView = "hubs";

            // Initialize graph visualization
            function initGraph() {
                const svg = document.getElementById("graph");

                // Clear existing content except defs
                const defs = svg.querySelector("defs");
                svg.innerHTML = "";
                if (defs) svg.appendChild(defs);

                // Draw edges with arrows
                edges.forEach((edge) => {
                    const sourceNode = nodes.find((n) => n.id === edge.source);
                    const targetNode = nodes.find((n) => n.id === edge.target);

                    // Calculate arrow position (edge of target circle)
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const unitX = dx / dist;
                    const unitY = dy / dist;
                    const radius = 25;

                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", sourceNode.x + unitX * radius);
                    line.setAttribute("y1", sourceNode.y + unitY * radius);
                    line.setAttribute("x2", targetNode.x - unitX * radius);
                    line.setAttribute("y2", targetNode.y - unitY * radius);
                    line.setAttribute("stroke", "#666");
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("class", "arrow");
                    svg.appendChild(line);
                });

                // Draw nodes
                nodes.forEach((node) => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("id", `node-group-${node.id}`);

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", node.x);
                    circle.setAttribute("cy", node.y);
                    circle.setAttribute("r", "25");
                    circle.setAttribute("fill", "#e0e0e0");
                    circle.setAttribute("stroke", "#333");
                    circle.setAttribute("stroke-width", "2");
                    circle.setAttribute("id", `node-${node.id}`);

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", node.x);
                    text.setAttribute("y", node.y - 8);
                    text.setAttribute("class", "node-text");
                    text.textContent = node.id;

                    const hubText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    hubText.setAttribute("x", node.x - 12);
                    hubText.setAttribute("y", node.y + 8);
                    hubText.setAttribute("class", "score-text hub-score");
                    hubText.setAttribute("id", `hub-${node.id}`);
                    hubText.textContent = "H:0.00";

                    const authText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    authText.setAttribute("x", node.x + 12);
                    authText.setAttribute("y", node.y + 8);
                    authText.setAttribute("class", "score-text auth-score");
                    authText.setAttribute("id", `auth-${node.id}`);
                    authText.textContent = "A:0.00";

                    g.appendChild(circle);
                    g.appendChild(text);
                    g.appendChild(hubText);
                    g.appendChild(authText);
                    svg.appendChild(g);
                });

                // Initialize UI
                updateSpeedDisplay();
                loadCodeExample();

                // Code toggle functionality
                document.getElementById("code-toggle").addEventListener("click", function () {
                    const codeContent = document.getElementById("code-content");
                    const toggle = document.getElementById("code-toggle");

                    if (codeContent.classList.contains("collapsed")) {
                        codeContent.classList.remove("collapsed");
                        codeContent.style.maxHeight = codeContent.scrollHeight + "px";
                        toggle.textContent = "Hide Code ▲";
                    } else {
                        codeContent.classList.add("collapsed");
                        codeContent.style.maxHeight = "0";
                        toggle.textContent = "Show Code ▼";
                    }
                });

                // Initially show code
                const codeContent = document.getElementById("code-content");
                codeContent.style.maxHeight = codeContent.scrollHeight + "px";
            }

            // Update speed display
            function updateSpeedDisplay() {
                const speed = document.getElementById("animation-speed").value;
                document.getElementById("speed-value").textContent = (speed / 1000).toFixed(1) + "s";
                animationSpeed = parseInt(speed);
            }

            // Event listener for settings
            document.getElementById("animation-speed").addEventListener("input", updateSpeedDisplay);

            // Get color based on score and view
            function getScoreColor(hubScore, authScore, view) {
                if (view === "hubs") {
                    const intensity = Math.min(hubScore * 2, 1); // Scale for visibility
                    const r = Math.round(233 + (233 - 233) * intensity); // Pink/red for hubs
                    const g = Math.round(30 + (30 - 30) * intensity);
                    const b = Math.round(99 + (99 - 99) * intensity);
                    return `rgb(${r}, ${g}, ${b})`;
                } else if (view === "authorities") {
                    const intensity = Math.min(authScore * 2, 1); // Scale for visibility
                    const r = Math.round(63 + (63 - 63) * intensity); // Blue for authorities
                    const g = Math.round(81 + (81 - 81) * intensity);
                    const b = Math.round(181 + (181 - 181) * intensity);
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // combined
                    const hubIntensity = Math.min(hubScore * 2, 1);
                    const authIntensity = Math.min(authScore * 2, 1);
                    const combined = (hubIntensity + authIntensity) / 2;
                    const r = Math.round(156 + (156 - 156) * combined); // Purple for combined
                    const g = Math.round(39 + (39 - 39) * combined);
                    const b = Math.round(176 + (176 - 176) * combined);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }

            // Set view mode
            window.setView = function (view) {
                currentView = view;

                // Update buttons
                document.querySelectorAll(".view-btn").forEach((btn) => btn.classList.remove("active"));
                document.getElementById(`view-${view}`).classList.add("active");

                // Update visualization
                updateVisualization(hubScores, authorityScores);
            };

            // Update visualization with current scores
            function updateVisualization(hubs, authorities, iteration = null) {
                // Update nodes
                nodes.forEach((node) => {
                    const hubScore = hubs.get(node.id) || 0;
                    const authScore = authorities.get(node.id) || 0;

                    const circle = document.getElementById(`node-${node.id}`);
                    const hubText = document.getElementById(`hub-${node.id}`);
                    const authText = document.getElementById(`auth-${node.id}`);

                    if (circle && hubText && authText) {
                        circle.setAttribute("fill", getScoreColor(hubScore, authScore, currentView));
                        hubText.textContent = `H:${hubScore.toFixed(2)}`;
                        authText.textContent = `A:${authScore.toFixed(2)}`;
                    }
                });

                // Find top nodes
                let topHub = { node: "-", score: 0 };
                let topAuth = { node: "-", score: 0 };

                nodes.forEach((node) => {
                    const hubScore = hubs.get(node.id) || 0;
                    const authScore = authorities.get(node.id) || 0;

                    if (hubScore > topHub.score) {
                        topHub = { node: node.id, score: hubScore };
                    }
                    if (authScore > topAuth.score) {
                        topAuth = { node: node.id, score: authScore };
                    }
                });

                document.getElementById("top-hub").textContent = topHub.node;
                document.getElementById("top-authority").textContent = topAuth.node;

                if (iteration !== null) {
                    document.getElementById("current-iteration").textContent = iteration;
                    document.getElementById("iteration-info").style.display = "block";
                }
            }

            // Animate HITS algorithm
            async function animateHITS() {
                const graph = createGraph();
                const maxIterations = 15;
                const tolerance = 1e-6;

                // Initialize scores
                let currentHubs = new Map();
                let currentAuthorities = new Map();
                let previousHubs = new Map();
                let previousAuthorities = new Map();

                const initialValue = 1.0 / Math.sqrt(nodes.length);
                nodes.forEach((node) => {
                    currentHubs.set(node.id, initialValue);
                    currentAuthorities.set(node.id, initialValue);
                });

                updateVisualization(currentHubs, currentAuthorities);
                document.getElementById("step-info").textContent = "Starting with uniform hub and authority scores...";
                await new Promise((resolve) => setTimeout(resolve, animationSpeed));

                // Iterative computation
                let converged = false;
                let iteration = 0;

                for (iteration = 1; iteration <= maxIterations && !converged; iteration++) {
                    previousHubs = new Map(currentHubs);
                    previousAuthorities = new Map(currentAuthorities);

                    document.getElementById("iterations-count").textContent = iteration;
                    document.getElementById("iteration-step").textContent = "Updating authority scores...";

                    // Update authority scores
                    const newAuthorities = new Map();
                    for (const node of nodes) {
                        let authorityScore = 0;
                        const inNeighbors = Array.from(graph.inNeighbors(node.id));

                        // Highlight incoming edges
                        edges.forEach((edge) => {
                            if (edge.target === node.id) {
                                // Highlight the edge briefly
                            }
                        });

                        for (const inNeighbor of inNeighbors) {
                            authorityScore += previousHubs.get(inNeighbor.toString()) || 0;
                        }

                        newAuthorities.set(node.id, authorityScore);
                    }

                    await new Promise((resolve) => setTimeout(resolve, animationSpeed / 3));

                    document.getElementById("iteration-step").textContent = "Updating hub scores...";

                    // Update hub scores
                    const newHubs = new Map();
                    for (const node of nodes) {
                        let hubScore = 0;
                        const outNeighbors = Array.from(graph.outNeighbors(node.id));

                        for (const outNeighbor of outNeighbors) {
                            hubScore += previousAuthorities.get(outNeighbor.toString()) || 0;
                        }

                        newHubs.set(node.id, hubScore);
                    }

                    await new Promise((resolve) => setTimeout(resolve, animationSpeed / 3));

                    // Normalize scores
                    let authNorm = 0;
                    for (const value of newAuthorities.values()) {
                        authNorm += value * value;
                    }
                    authNorm = Math.sqrt(authNorm);

                    if (authNorm > 0) {
                        for (const [nodeId, value] of newAuthorities) {
                            newAuthorities.set(nodeId, value / authNorm);
                        }
                    }

                    let hubNorm = 0;
                    for (const value of newHubs.values()) {
                        hubNorm += value * value;
                    }
                    hubNorm = Math.sqrt(hubNorm);

                    if (hubNorm > 0) {
                        for (const [nodeId, value] of newHubs) {
                            newHubs.set(nodeId, value / hubNorm);
                        }
                    }

                    currentAuthorities = newAuthorities;
                    currentHubs = newHubs;

                    // Check for convergence
                    let maxDiff = 0;
                    for (const [nodeId, value] of currentHubs) {
                        const prevValue = previousHubs.get(nodeId) || 0;
                        const diff = Math.abs(value - prevValue);
                        maxDiff = Math.max(maxDiff, diff);
                    }
                    for (const [nodeId, value] of currentAuthorities) {
                        const prevValue = previousAuthorities.get(nodeId) || 0;
                        const diff = Math.abs(value - prevValue);
                        maxDiff = Math.max(maxDiff, diff);
                    }

                    updateVisualization(currentHubs, currentAuthorities, iteration);

                    if (maxDiff < tolerance) {
                        converged = true;
                        document.getElementById("convergence-status").textContent = "Converged";
                        document.getElementById("step-info").textContent = `Converged after ${iteration} iterations!`;
                    } else {
                        document.getElementById("step-info").textContent =
                            `Iteration ${iteration}: Scores are stabilizing...`;
                    }

                    await new Promise((resolve) => setTimeout(resolve, animationSpeed / 3));
                }

                if (!converged) {
                    document.getElementById("convergence-status").textContent = "Max Iter";
                    document.getElementById("step-info").textContent = `Reached maximum iterations (${maxIterations})`;
                }

                document.getElementById("iteration-info").style.display = "none";
                hubScores = currentHubs;
                authorityScores = currentAuthorities;
            }

            // Start algorithm
            window.startAlgorithm = async function () {
                if (isAnimating) return;

                const button = document.getElementById("start-btn");
                button.disabled = true;
                button.textContent = "Running...";
                isAnimating = true;

                try {
                    // Reset display
                    document.getElementById("top-hub").textContent = "-";
                    document.getElementById("top-authority").textContent = "-";
                    document.getElementById("iterations-count").textContent = "0";
                    document.getElementById("convergence-status").textContent = "-";
                    document.getElementById("iteration-info").style.display = "none";

                    // Run actual algorithm for console output
                    const graph = createGraph();
                    const result = hits(graph, {
                        maxIterations: 15,
                        tolerance: 1e-6,
                    });
                    console.log("HITS Result:", result);

                    // Animate the algorithm
                    await animateHITS();
                } finally {
                    button.disabled = false;
                    button.textContent = "Start HITS Algorithm";
                    isAnimating = false;
                }
            };

            // Initialize on load
            window.onload = initGraph;
        </script>
    </body>
</html>
