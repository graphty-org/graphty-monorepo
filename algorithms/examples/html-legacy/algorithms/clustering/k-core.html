<!doctype html>
<html lang="en">
    <head>
        <!-- Eruda Mobile Console -->
        <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
        <script>
            if (typeof eruda !== "undefined") {
                eruda.init();
                if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
                    eruda.show();
                }
            }
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>K-Core Decomposition - Simple Visual Explanation</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background: #f5f5f5;
            }

            h1 {
                color: #2c5aa0;
                text-align: center;
            }

            .container {
                background: white;
                border-radius: 8px;
                padding: 30px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            #graph {
                width: 100%;
                height: 400px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                margin: 20px 0;
            }

            .controls {
                text-align: center;
                margin: 20px 0;
            }

            button {
                background: #4caf50;
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 6px;
                cursor: pointer;
                transition: background 0.3s;
                margin: 0 5px;
            }

            button:hover {
                background: #45a049;
            }

            button:disabled {
                background: #ccc;
                cursor: not-allowed;
            }

            .explanation {
                background: #e8f0fe;
                border-left: 4px solid #2c5aa0;
                padding: 15px;
                margin: 20px 0;
                border-radius: 4px;
            }

            .step-info {
                text-align: center;
                font-size: 18px;
                color: #333;
                margin: 20px 0;
                min-height: 30px;
            }

            .legend {
                display: flex;
                justify-content: center;
                gap: 20px;
                margin: 20px 0;
                flex-wrap: wrap;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .legend-circle {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid #333;
            }

            .core-0 {
                background: #e0e0e0;
            }
            .core-1 {
                background: #96ceb4;
            }
            .core-2 {
                background: #4ecdc4;
            }
            .core-3 {
                background: #45b7d1;
            }
            .core-4 {
                background: #ff6b6b;
            }
            .core-5 {
                background: #f39c12;
            }
            .removing {
                background: #ff4757;
                opacity: 0.5;
            }

            .intro {
                text-align: center;
                color: #666;
                margin: 20px 0;
            }

            .k-value-control {
                text-align: center;
                margin: 20px 0;
            }

            .k-value-control label {
                margin-right: 10px;
            }

            .k-value-control input[type="range"] {
                width: 200px;
                vertical-align: middle;
            }

            .k-value-control span {
                margin-left: 10px;
                font-weight: bold;
                font-size: 18px;
            }

            .core-display {
                background: #f0f0f0;
                padding: 15px;
                border-radius: 6px;
                margin: 20px 0;
            }

            .core-display h4 {
                margin: 0 0 10px 0;
                color: #666;
            }

            .core-list {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin-top: 10px;
            }

            .core-item {
                background: white;
                padding: 10px;
                border-radius: 4px;
                text-align: center;
                border-left: 4px solid #4caf50;
            }

            .core-item .core-name {
                font-weight: bold;
                margin-bottom: 5px;
            }

            .core-item .core-nodes {
                font-size: 12px;
                color: #666;
            }

            .back-link {
                color: #2c5aa0;
                text-decoration: none;
                margin-bottom: 20px;
                display: inline-block;
            }

            .back-link:hover {
                text-decoration: underline;
            }

            .code-section {
                margin-top: 30px;
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .code-toggle {
                background: #666;
                color: white;
                border: none;
                padding: 5px 10px;
                font-size: 12px;
                border-radius: 4px;
                cursor: pointer;
            }

            .code-content {
                overflow: hidden;
                transition: max-height 0.3s ease;
                max-height: 1000px;
            }

            .code-content.collapsed {
                max-height: 0;
            }

            .degree-label {
                font-size: 10px;
                fill: #666;
            }
        </style>
    </head>
    <body>
        <a href="../../index.html" class="back-link">← Back to Examples</a>

        <h1>K-Core Decomposition Explained</h1>

        <div class="container">
            <div class="intro">
                <p><strong>K-Core finds the most densely connected parts of a network.</strong></p>
                <p>Like peeling an onion, it removes less connected nodes layer by layer to reveal the core!</p>
            </div>

            <svg id="graph"></svg>

            <div class="k-value-control">
                <label for="k-value">K value:</label>
                <input type="range" id="k-value" min="0" max="4" step="1" value="0" />
                <span id="k-value-display">0</span>
            </div>

            <div class="step-info" id="step-info">
                Adjust K to see different core levels, or click "Decompose" for animation
            </div>

            <div class="legend" id="legend">
                <div class="legend-item">
                    <div class="legend-circle core-0"></div>
                    <span>0-core</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle core-1"></div>
                    <span>1-core</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle core-2"></div>
                    <span>2-core</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle core-3"></div>
                    <span>3-core</span>
                </div>
            </div>

            <div class="controls">
                <button id="decompose-btn" onclick="startDecomposition()">Decompose Network</button>
                <button id="reset-btn" onclick="resetVisualization()">Reset</button>
            </div>

            <div class="core-display" id="core-display" style="display: none">
                <h4>K-Core Decomposition Results:</h4>
                <div class="core-list" id="core-list"></div>
            </div>

            <div class="explanation">
                <h3>Key Concept:</h3>
                <p>
                    A k-core is a maximal subgraph where every node has at least k neighbors within that subgraph. The
                    algorithm works by:
                </p>
                <ul>
                    <li><strong>Iterative removal:</strong> Remove nodes with degree less than k</li>
                    <li><strong>Cascading effect:</strong> Removal may reduce other nodes' degrees</li>
                    <li>
                        <strong>Core assignment:</strong> Each node gets a coreness value (maximum k for which it
                        belongs to a k-core)
                    </li>
                </ul>
                <p>Higher k-cores represent more densely connected, cohesive groups in the network.</p>
            </div>

            <div class="code-section">
                <div class="code-header">
                    <h3>Code Example</h3>
                    <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
                </div>
                <div class="code-content" id="code-content">
                    <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

        <script type="module">
            // Import the k-core decomposition function
            import { runKCoreDecomposition } from "./k-core.js";

            // Load and display the actual code
            async function loadCodeExample() {
                try {
                    const response = await fetch("./k-core.js");
                    const code = await response.text();

                    // Extract the main function for display
                    const functionMatch = code.match(/export function runKCoreDecomposition[\s\S]*?^}/m);
                    if (functionMatch) {
                        document.getElementById("code-display").textContent = functionMatch[0];
                        Prism.highlightElement(document.getElementById("code-display"));
                    } else {
                        document.getElementById("code-display").textContent = code;
                        Prism.highlightElement(document.getElementById("code-display"));
                    }
                } catch (error) {
                    document.getElementById("code-display").textContent = `// Example usage of k-core decomposition
import { kCoreDecomposition } from '@graphty/algorithms';

// Create a graph (as adjacency list)
const graph = new Map([
    ['A', new Set(['B', 'C', 'D'])],
    ['B', new Set(['A', 'C', 'D', 'E'])],
    // ... more nodes
]);

// Run k-core decomposition
const result = kCoreDecomposition(graph);

console.log('Coreness:', result.coreness);
console.log('Max core:', result.maxCore);`;
                    Prism.highlightElement(document.getElementById("code-display"));
                }
            }

            // Graph structure - network with varying connectivity
            const nodes = [
                // Dense core (4-core)
                { id: "A", x: 250, y: 200, core: 4 },
                { id: "B", x: 200, y: 150, core: 4 },
                { id: "C", x: 300, y: 150, core: 4 },
                { id: "D", x: 200, y: 250, core: 4 },
                { id: "E", x: 300, y: 250, core: 4 },

                // 3-core nodes
                { id: "F", x: 150, y: 200, core: 3 },
                { id: "G", x: 350, y: 200, core: 3 },

                // 2-core nodes
                { id: "H", x: 100, y: 150, core: 2 },
                { id: "I", x: 400, y: 150, core: 2 },
                { id: "J", x: 100, y: 250, core: 2 },
                { id: "K", x: 400, y: 250, core: 2 },

                // 1-core nodes (peripheral)
                { id: "L", x: 50, y: 100, core: 1 },
                { id: "M", x: 450, y: 100, core: 1 },
                { id: "N", x: 50, y: 300, core: 1 },
                { id: "O", x: 450, y: 300, core: 1 },
            ];

            const edges = [
                // Dense core connections (complete subgraph)
                { source: "A", target: "B" },
                { source: "A", target: "C" },
                { source: "A", target: "D" },
                { source: "A", target: "E" },
                { source: "B", target: "C" },
                { source: "B", target: "D" },
                { source: "B", target: "E" },
                { source: "C", target: "D" },
                { source: "C", target: "E" },
                { source: "D", target: "E" },

                // 3-core connections
                { source: "F", target: "A" },
                { source: "F", target: "B" },
                { source: "F", target: "D" },
                { source: "G", target: "A" },
                { source: "G", target: "C" },
                { source: "G", target: "E" },

                // 2-core connections
                { source: "H", target: "F" },
                { source: "H", target: "B" },
                { source: "I", target: "G" },
                { source: "I", target: "C" },
                { source: "J", target: "F" },
                { source: "J", target: "D" },
                { source: "K", target: "G" },
                { source: "K", target: "E" },

                // 1-core connections
                { source: "L", target: "H" },
                { source: "M", target: "I" },
                { source: "N", target: "J" },
                { source: "O", target: "K" },
            ];

            let isDecomposing = false;
            let decompositionResult = null;
            let currentK = 0;

            // Initialize the graph visualization
            function initGraph() {
                const svg = document.getElementById("graph");
                svg.innerHTML = "";

                // Add edge elements
                edges.forEach((edge) => {
                    const source = nodes.find((n) => n.id === edge.source);
                    const target = nodes.find((n) => n.id === edge.target);

                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", source.x);
                    line.setAttribute("y1", source.y);
                    line.setAttribute("x2", target.x);
                    line.setAttribute("y2", target.y);
                    line.setAttribute("stroke", "#ddd");
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("id", `edge-${edge.source}-${edge.target}`);
                    svg.appendChild(line);
                });

                // Add node elements
                nodes.forEach((node) => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", node.x);
                    circle.setAttribute("cy", node.y);
                    circle.setAttribute("r", "20");
                    circle.setAttribute("fill", "#e0e0e0");
                    circle.setAttribute("stroke", "#333");
                    circle.setAttribute("stroke-width", "2");
                    circle.setAttribute("id", `node-${node.id}`);

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", node.x);
                    text.setAttribute("y", node.y + 5);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("font-weight", "bold");
                    text.textContent = node.id;

                    // Add degree label
                    const degreeText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    degreeText.setAttribute("x", node.x);
                    degreeText.setAttribute("y", node.y + 35);
                    degreeText.setAttribute("text-anchor", "middle");
                    degreeText.setAttribute("class", "degree-label");
                    degreeText.setAttribute("id", `degree-${node.id}`);

                    g.appendChild(circle);
                    g.appendChild(text);
                    g.appendChild(degreeText);
                    svg.appendChild(g);
                });

                updateDegreeLabels();
            }

            // Update degree labels
            function updateDegreeLabels() {
                const degrees = {};
                nodes.forEach((node) => (degrees[node.id] = 0));

                edges.forEach((edge) => {
                    degrees[edge.source]++;
                    degrees[edge.target]++;
                });

                nodes.forEach((node) => {
                    const label = document.getElementById(`degree-${node.id}`);
                    if (label) {
                        label.textContent = `deg: ${degrees[node.id]}`;
                    }
                });
            }

            // Start the k-core decomposition
            window.startDecomposition = async function () {
                if (isDecomposing) return;

                isDecomposing = true;
                document.getElementById("decompose-btn").disabled = true;
                document.getElementById("reset-btn").disabled = true;
                document.getElementById("k-value").disabled = true;
                document.getElementById("core-display").style.display = "none";

                // Reset all nodes
                nodes.forEach((node) => {
                    document.getElementById(`node-${node.id}`).setAttribute("fill", "#e0e0e0");
                });

                // Run the actual algorithm
                const result = runKCoreDecomposition(edges);
                console.log("K-Core Decomposition Result:", result);
                decompositionResult = result;

                // Animate the decomposition process
                await animateDecomposition(result);

                // Display results
                displayResults(result);

                isDecomposing = false;
                document.getElementById("reset-btn").disabled = false;
                document.getElementById("k-value").disabled = false;
            };

            // Animate the k-core decomposition process
            async function animateDecomposition(result) {
                const stepInfo = document.getElementById("step-info");

                // Show the decomposition process
                for (let k = 1; k <= result.maxCore; k++) {
                    stepInfo.textContent = `Finding ${k}-core: Removing nodes with degree < ${k}`;

                    // Highlight nodes that will be removed
                    nodes.forEach((node) => {
                        const coreness = result.coreness.get(node.id) || 0;
                        const nodeElement = document.getElementById(`node-${node.id}`);

                        if (coreness < k) {
                            nodeElement.setAttribute("fill", "#ff4757");
                            nodeElement.style.opacity = "0.5";
                        }
                    });

                    await sleep(1500);

                    // Update colors based on coreness
                    nodes.forEach((node) => {
                        const coreness = result.coreness.get(node.id) || 0;
                        const nodeElement = document.getElementById(`node-${node.id}`);

                        if (coreness >= k) {
                            nodeElement.setAttribute("fill", getColorForCore(k));
                            nodeElement.style.opacity = "1";
                        } else {
                            nodeElement.style.display = "none";
                        }
                    });

                    // Hide edges connected to removed nodes
                    edges.forEach((edge) => {
                        const sourceCoreness = result.coreness.get(edge.source) || 0;
                        const targetCoreness = result.coreness.get(edge.target) || 0;
                        const edgeElement = document.getElementById(`edge-${edge.source}-${edge.target}`);

                        if (sourceCoreness < k || targetCoreness < k) {
                            edgeElement.style.display = "none";
                        }
                    });

                    await sleep(1000);
                }

                // Show all nodes with their final colors
                nodes.forEach((node) => {
                    const nodeElement = document.getElementById(`node-${node.id}`);
                    nodeElement.style.display = "block";
                    nodeElement.style.opacity = "1";
                    const coreness = result.coreness.get(node.id) || 0;
                    nodeElement.setAttribute("fill", getColorForCore(coreness));
                });

                // Show all edges
                edges.forEach((edge) => {
                    const edgeElement = document.getElementById(`edge-${edge.source}-${edge.target}`);
                    edgeElement.style.display = "block";
                });

                stepInfo.textContent = `Decomposition complete! Max core: ${result.maxCore}`;
            }

            // Display the decomposition results
            function displayResults(result) {
                const coreDisplay = document.getElementById("core-display");
                const coreList = document.getElementById("core-list");

                // Clear previous results
                coreList.innerHTML = "";

                // Group nodes by coreness
                const coreGroups = {};
                result.coreness.forEach((coreness, nodeId) => {
                    if (!coreGroups[coreness]) {
                        coreGroups[coreness] = [];
                    }
                    coreGroups[coreness].push(nodeId);
                });

                // Display each core group
                Object.entries(coreGroups)
                    .sort(([a], [b]) => parseInt(b) - parseInt(a))
                    .forEach(([coreness, nodeIds]) => {
                        const coreItem = document.createElement("div");
                        coreItem.className = "core-item";
                        coreItem.style.borderLeftColor = getColorForCore(parseInt(coreness));

                        coreItem.innerHTML = `
                        <div class="core-name">${coreness}-core</div>
                        <div class="core-nodes">Nodes: ${nodeIds.join(", ")}</div>
                    `;

                        coreList.appendChild(coreItem);
                    });

                coreDisplay.style.display = "block";
            }

            // K-value slider functionality
            document.getElementById("k-value").addEventListener("input", function (e) {
                if (isDecomposing || !decompositionResult) return;

                currentK = parseInt(e.target.value);
                document.getElementById("k-value-display").textContent = currentK;

                // Update visualization based on k-value
                nodes.forEach((node) => {
                    const coreness = decompositionResult.coreness.get(node.id) || 0;
                    const nodeElement = document.getElementById(`node-${node.id}`);

                    if (coreness >= currentK) {
                        nodeElement.style.display = "block";
                        nodeElement.setAttribute("fill", getColorForCore(coreness));
                    } else {
                        nodeElement.style.display = "none";
                    }
                });

                // Update edges
                edges.forEach((edge) => {
                    const sourceCoreness = decompositionResult.coreness.get(edge.source) || 0;
                    const targetCoreness = decompositionResult.coreness.get(edge.target) || 0;
                    const edgeElement = document.getElementById(`edge-${edge.source}-${edge.target}`);

                    if (sourceCoreness >= currentK && targetCoreness >= currentK) {
                        edgeElement.style.display = "block";
                    } else {
                        edgeElement.style.display = "none";
                    }
                });

                document.getElementById("step-info").textContent =
                    currentK === 0 ? "Showing all nodes" : `Showing ${currentK}-core and above`;
            });

            // Get color for core level
            function getColorForCore(core) {
                const colors = ["#e0e0e0", "#96ceb4", "#4ecdc4", "#45b7d1", "#ff6b6b", "#f39c12"];
                return colors[Math.min(core, colors.length - 1)];
            }

            // Reset the visualization
            window.resetVisualization = function () {
                document.getElementById("decompose-btn").disabled = false;
                document.getElementById("k-value").disabled = false;
                document.getElementById("k-value").value = 0;
                document.getElementById("k-value-display").textContent = "0";
                document.getElementById("core-display").style.display = "none";
                document.getElementById("step-info").textContent =
                    'Adjust K to see different core levels, or click "Decompose" for animation';

                // Reset all nodes and edges
                nodes.forEach((node) => {
                    const nodeElement = document.getElementById(`node-${node.id}`);
                    nodeElement.setAttribute("fill", "#e0e0e0");
                    nodeElement.style.display = "block";
                    nodeElement.style.opacity = "1";
                });

                edges.forEach((edge) => {
                    const edgeElement = document.getElementById(`edge-${edge.source}-${edge.target}`);
                    edgeElement.style.display = "block";
                });

                currentK = 0;
            };

            // Code toggle functionality
            document.getElementById("code-toggle").addEventListener("click", function () {
                const codeContent = document.getElementById("code-content");
                const toggle = document.getElementById("code-toggle");

                if (codeContent.classList.contains("collapsed")) {
                    codeContent.classList.remove("collapsed");
                    toggle.textContent = "Hide Code ▲";
                } else {
                    codeContent.classList.add("collapsed");
                    toggle.textContent = "Show Code ▼";
                }
            });

            // Helper sleep function
            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            // Initialize on load
            window.onload = function () {
                initGraph();
                loadCodeExample();
            };
        </script>
    </body>
</html>
