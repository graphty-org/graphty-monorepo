<!doctype html>
<html lang="en">
    <head>
        <!-- MANDATORY: Eruda Mobile Console (exact code) -->
        <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
        <script>
            if (typeof eruda !== "undefined") {
                eruda.init();
                if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
                    eruda.show();
                }
            }
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Spectral Clustering - Simple Visual Explanation</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
        <style>
            /* MANDATORY STYLES - DO NOT MODIFY */
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background: #f5f5f5; /* Light gray background */
            }

            h1 {
                color: #2c5aa0; /* Blue header */
                text-align: center;
            }

            .container {
                background: white;
                border-radius: 8px;
                padding: 30px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            #graph {
                width: 100%;
                height: 400px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                margin: 20px 0;
            }

            button {
                background: #4caf50; /* Green button */
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 6px;
                cursor: pointer;
            }

            .explanation {
                background: #e8f0fe;
                border-left: 4px solid #2c5aa0;
                padding: 15px;
                margin: 20px 0;
                border-radius: 4px;
            }

            /* Additional algorithm-specific styles */
            .back-link {
                text-decoration: none;
                color: #2c5aa0;
                display: inline-block;
                margin-bottom: 20px;
                font-weight: 500;
            }

            .back-link:hover {
                text-decoration: underline;
            }

            .intro {
                margin-bottom: 20px;
            }

            .intro p {
                margin: 10px 0;
                line-height: 1.6;
            }

            .intro strong {
                color: #333;
            }

            .spectral-info {
                display: flex;
                justify-content: space-around;
                margin: 20px 0;
                background: #f8f9fa;
                padding: 15px;
                border-radius: 6px;
                flex-wrap: wrap;
                gap: 20px;
            }

            .spectral-stat {
                text-align: center;
                flex: 1;
                min-width: 150px;
            }

            .spectral-stat .value {
                font-size: 28px;
                font-weight: bold;
                color: #2c5aa0;
            }

            .spectral-stat .label {
                font-size: 14px;
                color: #666;
                margin-top: 5px;
            }

            .step-info {
                margin: 20px 0;
                padding: 15px;
                background: #f0f7ff;
                border-radius: 6px;
                font-size: 16px;
                text-align: center;
            }

            .legend {
                display: flex;
                gap: 20px;
                flex-wrap: wrap;
                margin-top: 15px;
                padding: 10px;
                background: #f8f9fa;
                border-radius: 6px;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .legend-color {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid #333;
            }

            button:hover {
                background: #45a049;
            }

            button:disabled {
                background: #ccc;
                cursor: not-allowed;
            }

            .controls {
                text-align: center;
                margin: 20px 0;
            }

            .algorithm-settings {
                display: flex;
                gap: 20px;
                margin: 20px 0;
                flex-wrap: wrap;
                justify-content: center;
            }

            .setting-group {
                display: flex;
                flex-direction: column;
                gap: 5px;
                align-items: center;
            }

            .setting-group label {
                font-size: 14px;
                color: #666;
            }

            .setting-group select,
            .setting-group input[type="range"] {
                width: 150px;
            }

            .setting-group span {
                font-weight: bold;
                color: #2c5aa0;
            }

            .explanation h3 {
                color: #2c5aa0;
                margin-top: 0;
            }

            .code-section {
                margin-top: 30px;
                border-top: 1px solid #e0e0e0;
                padding-top: 20px;
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .code-header h3 {
                margin: 0;
                color: #2c5aa0;
            }

            .code-toggle {
                background: none;
                border: 1px solid #2c5aa0;
                color: #2c5aa0;
                padding: 6px 12px;
                font-size: 14px;
                cursor: pointer;
                border-radius: 4px;
            }

            .code-toggle:hover {
                background: #2c5aa0;
                color: white;
            }

            .code-content {
                background: #f8f9fa;
                border-radius: 6px;
                overflow: hidden;
                transition: max-height 0.3s ease;
            }

            .code-content.collapsed {
                max-height: 0;
            }

            pre {
                margin: 0;
                overflow-x: auto;
            }

            text {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            }

            /* Cluster colors */
            .cluster-0 {
                fill: #ff6b6b;
            }
            .cluster-1 {
                fill: #4ecdc4;
            }
            .cluster-2 {
                fill: #45b7d1;
            }
            .cluster-3 {
                fill: #f9ca24;
            }
            .cluster-4 {
                fill: #f0932b;
            }
            .cluster-5 {
                fill: #eb4d4b;
            }
            .cluster-6 {
                fill: #6ab04c;
            }

            /* Step animation */
            @keyframes pulse {
                0% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.5;
                    transform: scale(1.1);
                }
                100% {
                    opacity: 1;
                    transform: scale(1);
                }
            }

            .processing {
                animation: pulse 1s ease-in-out;
            }

            .matrix-viz {
                display: none;
                background: #f8f9fa;
                border-radius: 6px;
                padding: 15px;
                margin: 15px 0;
                text-align: center;
            }

            .matrix {
                display: inline-block;
                margin: 10px;
            }

            .matrix-title {
                font-size: 14px;
                font-weight: bold;
                margin-bottom: 10px;
                color: #2c5aa0;
            }

            .matrix-grid {
                display: grid;
                gap: 2px;
                font-size: 10px;
                font-family: monospace;
            }

            .matrix-cell {
                background: white;
                border: 1px solid #ddd;
                width: 25px;
                height: 25px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 8px;
            }

            .eigenvector-viz {
                display: none;
                background: #fff3cd;
                border-radius: 6px;
                padding: 15px;
                margin: 15px 0;
            }

            .step-detail {
                background: #e8f0fe;
                border-radius: 4px;
                padding: 10px;
                margin: 10px 0;
                font-size: 14px;
                text-align: center;
            }
        </style>
    </head>
    <body>
        <a href="../../index.html" class="back-link">← Back to Examples</a>

        <h1>Spectral Clustering Explained</h1>

        <div class="container">
            <div class="intro">
                <p>
                    <strong
                        >Like using a mathematical x-ray to see hidden cluster patterns - reveals structure through
                        eigenvalues!</strong
                    >
                </p>
                <p>
                    Spectral Clustering uses the eigenvalues and eigenvectors of the graph's Laplacian matrix to uncover
                    cluster structure. It's particularly good at finding non-convex clusters that other methods miss.
                </p>
            </div>

            <svg id="graph"></svg>

            <div class="spectral-info">
                <div class="spectral-stat">
                    <div class="value" id="num-clusters">3</div>
                    <div class="label">Target Clusters</div>
                </div>
                <div class="spectral-stat">
                    <div class="value" id="current-step">1</div>
                    <div class="label">Current Step</div>
                </div>
                <div class="spectral-stat">
                    <div class="value" id="eigenvalues-computed">0</div>
                    <div class="label">Eigenvalues Found</div>
                </div>
            </div>

            <div class="step-detail" id="step-detail" style="display: none">Computing Laplacian matrix...</div>

            <div class="matrix-viz" id="matrix-viz">
                <div class="matrix" id="adjacency-matrix">
                    <div class="matrix-title">Adjacency Matrix</div>
                    <div class="matrix-grid" id="adj-grid"></div>
                </div>
                <div class="matrix" id="laplacian-matrix">
                    <div class="matrix-title">Laplacian Matrix</div>
                    <div class="matrix-grid" id="lap-grid"></div>
                </div>
            </div>

            <div class="eigenvector-viz" id="eigenvector-viz">
                <div class="matrix-title">Eigenvector Embedding Space</div>
                <p>Each point represents a node in the reduced dimensional space defined by the eigenvectors.</p>
            </div>

            <div class="step-info" id="step-info">Click "Start" to see how Spectral Clustering works</div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b"></div>
                    <span>Cluster 1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4"></div>
                    <span>Cluster 2</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #45b7d1"></div>
                    <span>Cluster 3</span>
                </div>
            </div>

            <div class="algorithm-settings">
                <div class="setting-group">
                    <label for="num-clusters">Number of Clusters</label>
                    <input type="range" id="num-clusters" min="2" max="5" value="3" step="1" />
                    <span id="clusters-value">3</span>
                </div>
                <div class="setting-group">
                    <label for="laplacian-type">Laplacian Type</label>
                    <select id="laplacian-type">
                        <option value="normalized">Normalized</option>
                        <option value="unnormalized">Unnormalized</option>
                        <option value="randomWalk">Random Walk</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="animation-speed">Animation Speed</label>
                    <input type="range" id="animation-speed" min="500" max="3000" value="1500" step="100" />
                    <span id="speed-value">1.5s</span>
                </div>
            </div>

            <div class="controls">
                <button id="start-btn" onclick="startAlgorithm()">Start Spectral Clustering</button>
            </div>

            <div class="explanation">
                <h3>Key Concept:</h3>
                <p>Spectral Clustering works in three main steps:</p>
                <p>
                    <strong>1. Build Laplacian Matrix:</strong> From the graph's adjacency matrix, compute the Laplacian
                    L = D - A (where D is the degree matrix)
                </p>
                <p>
                    <strong>2. Find Eigenvectors:</strong> Compute the k smallest eigenvectors of the Laplacian matrix
                </p>
                <p>
                    <strong>3. K-means Clustering:</strong> Treat each node's eigenvector values as coordinates and
                    cluster with k-means
                </p>
                <p>This mathematical approach can find clusters that aren't obvious from the graph structure alone!</p>
            </div>

            <div class="code-section">
                <div class="code-header">
                    <h3>Code Example</h3>
                    <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
                </div>
                <div class="code-content" id="code-content">
                    <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

        <script type="module">
            // Import the algorithm functions
            import { Graph } from "./algorithms.js";
            import { spectralClustering } from "./algorithms.js";

            // Cluster colors
            const clusterColors = ["#ff6b6b", "#4ecdc4", "#45b7d1", "#f9ca24", "#f0932b", "#eb4d4b", "#6ab04c"];

            // Load and display the actual code
            async function loadCodeExample() {
                try {
                    const response = await fetch("./spectral.js");
                    const code = await response.text();
                    document.getElementById("code-display").textContent = code;
                    Prism.highlightElement(document.getElementById("code-display"));
                } catch (error) {
                    document.getElementById("code-display").textContent =
                        `import { Graph, spectralClustering } from '@graphty/algorithms';

// Create a graph with cluster structure
const graph = new Graph();

// Add nodes
graph.addNode('A'); graph.addNode('B'); graph.addNode('C');
graph.addNode('D'); graph.addNode('E'); graph.addNode('F');
graph.addNode('G'); graph.addNode('H'); graph.addNode('I');

// Add edges to create 3 clusters
// Cluster 1: A-B-C triangle
graph.addEdge('A', 'B'); graph.addEdge('B', 'C'); graph.addEdge('C', 'A');

// Cluster 2: D-E-F triangle  
graph.addEdge('D', 'E'); graph.addEdge('E', 'F'); graph.addEdge('F', 'D');

// Cluster 3: G-H-I triangle
graph.addEdge('G', 'H'); graph.addEdge('H', 'I'); graph.addEdge('I', 'G');

// Weak inter-cluster connections
graph.addEdge('C', 'D'); graph.addEdge('F', 'G');

// Run Spectral Clustering
const result = spectralClustering(graph, {
    k: 3,
    laplacianType: 'normalized'
});

console.log('Clusters:', result.communities);
console.log('Cluster assignments:', result.clusterAssignments);`;
                    Prism.highlightElement(document.getElementById("code-display"));
                }
            }

            // Graph structure for visualization - three connected clusters
            const nodes = [
                // Cluster 1 - tightly connected triangle
                { id: "A", x: 150, y: 120 },
                { id: "B", x: 100, y: 180 },
                { id: "C", x: 200, y: 180 },

                // Cluster 2 - loosely connected group
                { id: "D", x: 350, y: 100 },
                { id: "E", x: 400, y: 160 },
                { id: "F", x: 450, y: 120 },

                // Cluster 3 - chain-like structure
                { id: "G", x: 200, y: 300 },
                { id: "H", x: 300, y: 350 },
                { id: "I", x: 400, y: 300 },
            ];

            const edges = [
                // Cluster 1 - dense triangle
                { source: "A", target: "B" },
                { source: "B", target: "C" },
                { source: "C", target: "A" },

                // Cluster 2 - sparse connections
                { source: "D", target: "E" },
                { source: "E", target: "F" },
                { source: "F", target: "D" },

                // Cluster 3 - chain
                { source: "G", target: "H" },
                { source: "H", target: "I" },
                { source: "I", target: "G" },

                // Inter-cluster connections (weak)
                { source: "C", target: "D" },
                { source: "F", target: "G" },
            ];

            // Create graph for algorithm
            function createGraph() {
                const graph = new Graph();

                // Add nodes
                nodes.forEach((node) => graph.addNode(node.id));

                // Add edges
                edges.forEach((edge) => graph.addEdge(edge.source, edge.target));

                return graph;
            }

            // Animation state
            let isAnimating = false;
            let clusterAssignments = new Map();
            let animationSpeed = 1500;

            // Initialize graph visualization
            function initGraph() {
                const svg = document.getElementById("graph");

                // Clear existing content
                svg.innerHTML = "";

                // Draw edges
                edges.forEach((edge) => {
                    const sourceNode = nodes.find((n) => n.id === edge.source);
                    const targetNode = nodes.find((n) => n.id === edge.target);

                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", sourceNode.x);
                    line.setAttribute("y1", sourceNode.y);
                    line.setAttribute("x2", targetNode.x);
                    line.setAttribute("y2", targetNode.y);
                    line.setAttribute("stroke", "#ccc");
                    line.setAttribute("stroke-width", "2");
                    svg.appendChild(line);
                });

                // Draw nodes
                nodes.forEach((node, index) => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", node.x);
                    circle.setAttribute("cy", node.y);
                    circle.setAttribute("r", "25");
                    circle.setAttribute("fill", "#e0e0e0");
                    circle.setAttribute("stroke", "#333");
                    circle.setAttribute("stroke-width", "2");
                    circle.setAttribute("id", `node-${node.id}`);

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", node.x);
                    text.setAttribute("y", node.y + 5);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("font-size", "16");
                    text.setAttribute("font-weight", "bold");
                    text.textContent = node.id;

                    g.appendChild(circle);
                    g.appendChild(text);
                    svg.appendChild(g);
                });

                // Initialize UI
                updateSettings();
                loadCodeExample();

                // Code toggle functionality
                document.getElementById("code-toggle").addEventListener("click", function () {
                    const codeContent = document.getElementById("code-content");
                    const toggle = document.getElementById("code-toggle");

                    if (codeContent.classList.contains("collapsed")) {
                        codeContent.classList.remove("collapsed");
                        codeContent.style.maxHeight = codeContent.scrollHeight + "px";
                        toggle.textContent = "Hide Code ▲";
                    } else {
                        codeContent.classList.add("collapsed");
                        codeContent.style.maxHeight = "0";
                        toggle.textContent = "Show Code ▼";
                    }
                });

                // Initially show code
                const codeContent = document.getElementById("code-content");
                codeContent.style.maxHeight = codeContent.scrollHeight + "px";
            }

            // Update settings displays
            function updateSettings() {
                const clusters = document.getElementById("num-clusters").value;
                const speed = document.getElementById("animation-speed").value;

                document.getElementById("clusters-value").textContent = clusters;
                document.getElementById("speed-value").textContent = (speed / 1000).toFixed(1) + "s";
                document.getElementById("num-clusters").textContent = clusters;
                animationSpeed = parseInt(speed);
            }

            // Event listeners for settings
            document.getElementById("num-clusters").addEventListener("input", updateSettings);
            document.getElementById("animation-speed").addEventListener("input", updateSettings);

            // Visualize clusters
            function visualizeClusters(assignments, message) {
                // Update node colors based on cluster assignments
                assignments.forEach((clusterId, nodeId) => {
                    const circle = document.getElementById(`node-${nodeId}`);
                    if (circle) {
                        const clusterColor = clusterColors[clusterId % clusterColors.length];
                        circle.setAttribute("fill", clusterColor);
                    }
                });

                // Update step info
                if (message) {
                    document.getElementById("step-info").textContent = message;
                }
            }

            // Create simple matrix visualization
            function showMatrix(matrixData, containerId, title) {
                const container = document.getElementById(containerId);
                const grid = container.querySelector(".matrix-grid");

                if (!grid) return;

                const n = matrixData.length;
                grid.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
                grid.innerHTML = "";

                // Add matrix cells
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const cell = document.createElement("div");
                        cell.className = "matrix-cell";
                        const value = matrixData[i][j];
                        cell.textContent = typeof value === "number" ? value.toFixed(1) : "0";

                        // Color coding
                        if (Math.abs(value) > 0.1) {
                            cell.style.background = value > 0 ? "#ffebee" : "#e8f5e8";
                        }

                        grid.appendChild(cell);
                    }
                }
            }

            // Animate spectral clustering
            async function animateSpectralClustering() {
                const graph = createGraph();
                const k = parseInt(document.getElementById("num-clusters").value);
                const laplacianType = document.getElementById("laplacian-type").value;

                // Step 1: Show matrices
                document.getElementById("current-step").textContent = "1";
                document.getElementById("step-detail").style.display = "block";
                document.getElementById("step-detail").textContent =
                    "Step 1: Building adjacency and Laplacian matrices...";

                // Create simple adjacency matrix for visualization
                const nodeMap = new Map();
                nodes.forEach((node, i) => nodeMap.set(node.id, i));

                const adjMatrix = Array(nodes.length)
                    .fill(null)
                    .map(() => Array(nodes.length).fill(0));
                edges.forEach((edge) => {
                    const i = nodeMap.get(edge.source);
                    const j = nodeMap.get(edge.target);
                    if (i !== undefined && j !== undefined) {
                        adjMatrix[i][j] = 1;
                        adjMatrix[j][i] = 1;
                    }
                });

                // Create simple Laplacian matrix (degree - adjacency)
                const lapMatrix = Array(nodes.length)
                    .fill(null)
                    .map(() => Array(nodes.length).fill(0));
                for (let i = 0; i < nodes.length; i++) {
                    let degree = 0;
                    for (let j = 0; j < nodes.length; j++) {
                        if (adjMatrix[i][j]) degree++;
                    }
                    lapMatrix[i][i] = degree;
                    for (let j = 0; j < nodes.length; j++) {
                        if (i !== j) lapMatrix[i][j] = -adjMatrix[i][j];
                    }
                }

                showMatrix(adjMatrix, "adjacency-matrix", "Adjacency");
                showMatrix(lapMatrix, "laplacian-matrix", "Laplacian");
                document.getElementById("matrix-viz").style.display = "block";

                await new Promise((resolve) => setTimeout(resolve, animationSpeed));

                // Step 2: Eigendecomposition
                document.getElementById("current-step").textContent = "2";
                document.getElementById("step-detail").textContent =
                    "Step 2: Computing eigenvalues and eigenvectors...";

                // Highlight processing
                nodes.forEach((node) => {
                    const circle = document.getElementById(`node-${node.id}`);
                    circle.classList.add("processing");
                });

                await new Promise((resolve) => setTimeout(resolve, animationSpeed));

                // Remove processing animation
                nodes.forEach((node) => {
                    const circle = document.getElementById(`node-${node.id}`);
                    circle.classList.remove("processing");
                });

                document.getElementById("eigenvalues-computed").textContent = k;
                document.getElementById("eigenvector-viz").style.display = "block";

                await new Promise((resolve) => setTimeout(resolve, animationSpeed));

                // Step 3: K-means clustering
                document.getElementById("current-step").textContent = "3";
                document.getElementById("step-detail").textContent =
                    "Step 3: Applying k-means clustering in eigenvector space...";

                await new Promise((resolve) => setTimeout(resolve, animationSpeed));

                // Run actual algorithm
                const result = spectralClustering(graph, {
                    k: k,
                    laplacianType: laplacianType,
                });

                // Animate cluster assignment
                const assignments = new Map();
                for (const [nodeId, clusterId] of result.clusterAssignments.entries()) {
                    assignments.set(nodeId, clusterId);
                }

                visualizeClusters(
                    assignments,
                    `Spectral clustering complete! Found ${result.communities.length} clusters.`,
                );

                // Hide matrix visualizations
                document.getElementById("matrix-viz").style.display = "none";
                document.getElementById("eigenvector-viz").style.display = "none";
                document.getElementById("step-detail").style.display = "none";

                clusterAssignments = assignments;

                return result;
            }

            // Start algorithm
            window.startAlgorithm = async function () {
                if (isAnimating) return;

                const button = document.getElementById("start-btn");
                button.disabled = true;
                button.textContent = "Running...";
                isAnimating = true;

                try {
                    // Reset display
                    document.getElementById("current-step").textContent = "1";
                    document.getElementById("eigenvalues-computed").textContent = "0";
                    document.getElementById("matrix-viz").style.display = "none";
                    document.getElementById("eigenvector-viz").style.display = "none";
                    document.getElementById("step-detail").style.display = "none";

                    // Reset node colors
                    nodes.forEach((node) => {
                        const circle = document.getElementById(`node-${node.id}`);
                        circle.setAttribute("fill", "#e0e0e0");
                    });

                    // Run actual algorithm for console output
                    const graph = createGraph();
                    const k = parseInt(document.getElementById("num-clusters").value);
                    const laplacianType = document.getElementById("laplacian-type").value;

                    const result = spectralClustering(graph, {
                        k: k,
                        laplacianType: laplacianType,
                    });
                    console.log("Spectral Clustering Result:", result);

                    // Animate the algorithm
                    await animateSpectralClustering();
                } finally {
                    button.disabled = false;
                    button.textContent = "Start Spectral Clustering";
                    isAnimating = false;
                }
            };

            // Initialize on load
            window.onload = initGraph;
        </script>
    </body>
</html>
