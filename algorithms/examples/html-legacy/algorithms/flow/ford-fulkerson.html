<!doctype html>
<html lang="en">
    <head>
        <!-- Eruda Mobile Console -->
        <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
        <script>
            if (typeof eruda !== "undefined") {
                eruda.init();
                if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
                    eruda.show();
                }
            }
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Ford-Fulkerson Maximum Flow - Simple Visual Explanation</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background: #f5f5f5;
            }

            h1 {
                color: #2c5aa0;
                text-align: center;
            }

            .container {
                background: white;
                border-radius: 8px;
                padding: 30px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            #graph {
                width: 100%;
                height: 400px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                margin: 20px 0;
            }

            .controls {
                text-align: center;
                margin: 20px 0;
            }

            button {
                background: #4caf50;
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 6px;
                cursor: pointer;
                transition: background 0.3s;
                margin: 0 5px;
            }

            button:hover {
                background: #45a049;
            }

            button:disabled {
                background: #ccc;
                cursor: not-allowed;
            }

            .explanation {
                background: #e8f0fe;
                border-left: 4px solid #2c5aa0;
                padding: 15px;
                margin: 20px 0;
                border-radius: 4px;
            }

            .step-info {
                text-align: center;
                font-size: 18px;
                color: #333;
                margin: 20px 0;
                min-height: 30px;
            }

            .legend {
                display: flex;
                justify-content: center;
                gap: 20px;
                margin: 20px 0;
                flex-wrap: wrap;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .legend-circle {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid #333;
            }

            .source {
                background: #ff9800;
            }
            .sink {
                background: #2196f3;
            }
            .regular {
                background: #e0e0e0;
            }
            .path-node {
                background: #4caf50;
            }

            .intro {
                text-align: center;
                color: #666;
                margin: 20px 0;
            }

            .flow-display {
                background: #f0f0f0;
                padding: 15px;
                border-radius: 6px;
                margin: 20px 0;
            }

            .flow-display h4 {
                margin: 0 0 10px 0;
                color: #666;
            }

            .flow-info {
                display: flex;
                justify-content: space-around;
                text-align: center;
            }

            .flow-stat {
                padding: 10px;
            }

            .flow-stat .value {
                font-size: 24px;
                font-weight: bold;
                color: #2c5aa0;
            }

            .flow-stat .label {
                font-size: 14px;
                color: #666;
                margin-top: 5px;
            }

            .back-link {
                color: #2c5aa0;
                text-decoration: none;
                margin-bottom: 20px;
                display: inline-block;
            }

            .back-link:hover {
                text-decoration: underline;
            }

            .code-section {
                margin-top: 30px;
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .code-toggle {
                background: #666;
                color: white;
                border: none;
                padding: 5px 10px;
                font-size: 12px;
                border-radius: 4px;
                cursor: pointer;
            }

            .code-content {
                overflow: hidden;
                transition: max-height 0.3s ease;
                max-height: 1000px;
            }

            .code-content.collapsed {
                max-height: 0;
            }

            .edge-label {
                font-size: 11px;
                font-weight: bold;
                fill: #333;
            }

            .edge-path {
                stroke: #999;
                stroke-width: 2;
                fill: none;
                marker-end: url(#arrowhead);
            }

            .edge-path.augmenting {
                stroke: #4caf50;
                stroke-width: 3;
            }

            .edge-path.saturated {
                stroke: #f44336;
                stroke-dasharray: 5, 5;
            }

            .path-info {
                background: #f9f9f9;
                padding: 10px;
                border-radius: 6px;
                margin: 10px 0;
                text-align: center;
                font-family: monospace;
                font-size: 14px;
            }
        </style>
    </head>
    <body>
        <a href="../../index.html" class="back-link">← Back to Examples</a>

        <h1>Ford-Fulkerson Maximum Flow Explained</h1>

        <div class="container">
            <div class="intro">
                <p>
                    <strong>Ford-Fulkerson finds the maximum flow through a network, like water through pipes.</strong>
                </p>
                <p>
                    It repeatedly finds paths from source to sink and pushes flow through them until no more flow is
                    possible.
                </p>
            </div>

            <svg id="graph">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="20" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#999" />
                    </marker>
                </defs>
            </svg>

            <div class="path-info" id="path-info">Click "Find Maximum Flow" to see how the algorithm works</div>

            <div class="step-info" id="step-info">Ready to find the maximum flow from source to sink</div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-circle source"></div>
                    <span>Source</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle sink"></div>
                    <span>Sink</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle path-node"></div>
                    <span>Current Path</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle regular"></div>
                    <span>Regular Node</span>
                </div>
            </div>

            <div class="controls">
                <button id="find-btn" onclick="startFindingFlow()">Find Maximum Flow</button>
                <button id="reset-btn" onclick="resetVisualization()">Reset</button>
            </div>

            <div class="flow-display" id="flow-display" style="display: none">
                <h4>Flow Network Status:</h4>
                <div class="flow-info">
                    <div class="flow-stat">
                        <div class="value" id="current-flow">0</div>
                        <div class="label">Current Flow</div>
                    </div>
                    <div class="flow-stat">
                        <div class="value" id="max-flow">?</div>
                        <div class="label">Maximum Flow</div>
                    </div>
                    <div class="flow-stat">
                        <div class="value" id="iterations">0</div>
                        <div class="label">Iterations</div>
                    </div>
                </div>
            </div>

            <div class="explanation">
                <h3>Key Concept:</h3>
                <p>Ford-Fulkerson algorithm finds the maximum flow in a network by:</p>
                <ul>
                    <li>
                        <strong>Finding augmenting paths:</strong> Paths from source to sink with available capacity
                    </li>
                    <li><strong>Pushing flow:</strong> Send as much flow as possible through each path</li>
                    <li><strong>Residual graph:</strong> Track remaining capacities and allow flow reversal</li>
                    <li><strong>Termination:</strong> When no more augmenting paths exist</li>
                </ul>
                <p>Applications include network routing, matching problems, and resource allocation.</p>
            </div>

            <div class="code-section">
                <div class="code-header">
                    <h3>Code Example</h3>
                    <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
                </div>
                <div class="code-content" id="code-content">
                    <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

        <script type="module">
            // Import the Ford-Fulkerson function
            import { runFordFulkerson } from "./ford-fulkerson.js";

            // Load and display the actual code
            async function loadCodeExample() {
                try {
                    const response = await fetch("./ford-fulkerson.js");
                    const code = await response.text();

                    // Extract the main function for display
                    const functionMatch = code.match(/export function runFordFulkerson[\s\S]*?^}/m);
                    if (functionMatch) {
                        document.getElementById("code-display").textContent = functionMatch[0];
                        Prism.highlightElement(document.getElementById("code-display"));
                    } else {
                        document.getElementById("code-display").textContent = code;
                        Prism.highlightElement(document.getElementById("code-display"));
                    }
                } catch (error) {
                    document.getElementById("code-display").textContent = `// Example usage of Ford-Fulkerson algorithm
import { fordFulkerson } from '@graphty/algorithms';

// Create a flow network (adjacency list with capacities)
const graph = new Map([
    ['S', new Map([['A', 10], ['B', 10]])],
    ['A', new Map([['B', 2], ['T', 4]])],
    ['B', new Map([['C', 9], ['T', 10]])],
    // ... more edges with capacities
]);

// Find maximum flow from source to sink
const result = fordFulkerson(graph, 'S', 'T');
console.log('Maximum flow:', result.maxFlow);`;
                    Prism.highlightElement(document.getElementById("code-display"));
                }
            }

            // Graph structure - flow network
            const nodes = [
                { id: "S", x: 100, y: 200, label: "Source" },
                { id: "A", x: 250, y: 100 },
                { id: "B", x: 250, y: 300 },
                { id: "C", x: 400, y: 100 },
                { id: "D", x: 400, y: 300 },
                { id: "T", x: 550, y: 200, label: "Sink" },
            ];

            const edges = [
                { source: "S", target: "A", capacity: 16 },
                { source: "S", target: "B", capacity: 13 },
                { source: "A", target: "B", capacity: 10 },
                { source: "A", target: "C", capacity: 12 },
                { source: "B", target: "D", capacity: 14 },
                { source: "C", target: "B", capacity: 4 },
                { source: "C", target: "T", capacity: 20 },
                { source: "D", target: "C", capacity: 7 },
                { source: "D", target: "T", capacity: 4 },
            ];

            let isRunning = false;
            let currentFlow = 0;
            let flowResult = null;
            let iterations = 0;
            const edgeFlows = {};

            // Initialize the graph visualization
            function initGraph() {
                const svg = document.getElementById("graph");
                svg.innerHTML = svg.innerHTML; // Keep defs

                // Initialize edge flows
                edges.forEach((edge) => {
                    edgeFlows[`${edge.source}-${edge.target}`] = 0;
                });

                // Add edge elements
                edges.forEach((edge, index) => {
                    const source = nodes.find((n) => n.id === edge.source);
                    const target = nodes.find((n) => n.id === edge.target);

                    // Calculate control point for curved edges
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);

                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", `M ${source.x} ${source.y} L ${target.x} ${target.y}`);
                    path.setAttribute("class", "edge-path");
                    path.setAttribute("id", `edge-${edge.source}-${edge.target}`);
                    svg.appendChild(path);

                    // Add capacity/flow label
                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", (source.x + target.x) / 2);
                    text.setAttribute("y", (source.y + target.y) / 2 - 10);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("class", "edge-label");
                    text.setAttribute("id", `label-${edge.source}-${edge.target}`);
                    text.textContent = `0/${edge.capacity}`;
                    svg.appendChild(text);
                });

                // Add node elements
                nodes.forEach((node) => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", node.x);
                    circle.setAttribute("cy", node.y);
                    circle.setAttribute("r", "25");

                    let fillColor = "#e0e0e0";
                    if (node.id === "S") fillColor = "#ff9800";
                    else if (node.id === "T") fillColor = "#2196F3";

                    circle.setAttribute("fill", fillColor);
                    circle.setAttribute("stroke", "#333");
                    circle.setAttribute("stroke-width", "2");
                    circle.setAttribute("id", `node-${node.id}`);

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", node.x);
                    text.setAttribute("y", node.y + 5);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("font-weight", "bold");
                    text.textContent = node.id;

                    g.appendChild(circle);
                    g.appendChild(text);
                    svg.appendChild(g);
                });
            }

            // Start finding maximum flow
            window.startFindingFlow = async function () {
                if (isRunning) return;

                isRunning = true;
                currentFlow = 0;
                iterations = 0;
                document.getElementById("find-btn").disabled = true;
                document.getElementById("reset-btn").disabled = true;
                document.getElementById("flow-display").style.display = "block";

                // Reset displays
                document.getElementById("current-flow").textContent = "0";
                document.getElementById("max-flow").textContent = "?";
                document.getElementById("iterations").textContent = "0";

                // Run the actual algorithm
                const result = runFordFulkerson();
                console.log("Ford-Fulkerson Result:", result);
                flowResult = result;

                // Animate the flow finding process
                await animateFlowFinding(result);

                isRunning = false;
                document.getElementById("reset-btn").disabled = false;
            };

            // Animate the Ford-Fulkerson algorithm
            async function animateFlowFinding(result) {
                const stepInfo = document.getElementById("step-info");
                const pathInfo = document.getElementById("path-info");

                // Simulate finding augmenting paths
                const simulatedPaths = [
                    { path: ["S", "A", "C", "T"], flow: 12 },
                    { path: ["S", "B", "D", "T"], flow: 4 },
                    { path: ["S", "B", "D", "C", "T"], flow: 7 },
                    { path: ["S", "A", "B", "D", "T"], flow: 0 }, // No more capacity
                ];

                for (const pathData of simulatedPaths) {
                    iterations++;
                    document.getElementById("iterations").textContent = iterations;

                    if (pathData.flow === 0) {
                        stepInfo.textContent = "No more augmenting paths found!";
                        pathInfo.textContent = "Maximum flow reached";
                        break;
                    }

                    stepInfo.textContent = `Finding augmenting path (Iteration ${iterations})`;
                    pathInfo.textContent = `Path found: ${pathData.path.join(" → ")}`;

                    // Highlight the path
                    for (let i = 0; i < pathData.path.length; i++) {
                        const nodeId = pathData.path[i];
                        const nodeElement = document.getElementById(`node-${nodeId}`);

                        if (nodeId !== "S" && nodeId !== "T") {
                            nodeElement.setAttribute("fill", "#4CAF50");
                        }

                        if (i < pathData.path.length - 1) {
                            const edgeId = `edge-${pathData.path[i]}-${pathData.path[i + 1]}`;
                            const edgeElement = document.getElementById(edgeId);
                            if (edgeElement) {
                                edgeElement.classList.add("augmenting");
                            }
                        }

                        await sleep(300);
                    }

                    await sleep(1000);

                    // Update flow
                    currentFlow += pathData.flow;
                    document.getElementById("current-flow").textContent = currentFlow;
                    stepInfo.textContent = `Pushing flow of ${pathData.flow} units through path`;

                    // Update edge labels
                    for (let i = 0; i < pathData.path.length - 1; i++) {
                        const source = pathData.path[i];
                        const target = pathData.path[i + 1];
                        const edge = edges.find((e) => e.source === source && e.target === target);

                        if (edge) {
                            const edgeKey = `${source}-${target}`;
                            edgeFlows[edgeKey] += pathData.flow;

                            const label = document.getElementById(`label-${source}-${target}`);
                            if (label) {
                                label.textContent = `${edgeFlows[edgeKey]}/${edge.capacity}`;

                                // Mark saturated edges
                                if (edgeFlows[edgeKey] === edge.capacity) {
                                    const edgeElement = document.getElementById(`edge-${source}-${target}`);
                                    if (edgeElement) {
                                        edgeElement.classList.add("saturated");
                                    }
                                }
                            }
                        }
                    }

                    await sleep(1000);

                    // Reset path highlighting
                    pathData.path.forEach((nodeId) => {
                        if (nodeId !== "S" && nodeId !== "T") {
                            document.getElementById(`node-${nodeId}`).setAttribute("fill", "#e0e0e0");
                        }
                    });

                    edges.forEach((edge) => {
                        const edgeElement = document.getElementById(`edge-${edge.source}-${edge.target}`);
                        if (edgeElement) {
                            edgeElement.classList.remove("augmenting");
                        }
                    });
                }

                // Show final result
                document.getElementById("max-flow").textContent = result.maxFlow;
                stepInfo.textContent = `Maximum flow found: ${result.maxFlow} units`;
                pathInfo.textContent = "Algorithm complete - no more augmenting paths exist";
            }

            // Reset the visualization
            window.resetVisualization = function () {
                document.getElementById("find-btn").disabled = false;
                document.getElementById("flow-display").style.display = "none";
                document.getElementById("step-info").textContent = "Ready to find the maximum flow from source to sink";
                document.getElementById("path-info").textContent =
                    'Click "Find Maximum Flow" to see how the algorithm works';

                // Reset flows
                currentFlow = 0;
                iterations = 0;
                Object.keys(edgeFlows).forEach((key) => {
                    edgeFlows[key] = 0;
                });

                // Reset edge labels and styles
                edges.forEach((edge) => {
                    const label = document.getElementById(`label-${edge.source}-${edge.target}`);
                    if (label) {
                        label.textContent = `0/${edge.capacity}`;
                    }

                    const edgeElement = document.getElementById(`edge-${edge.source}-${edge.target}`);
                    if (edgeElement) {
                        edgeElement.classList.remove("augmenting", "saturated");
                    }
                });

                // Reset nodes
                nodes.forEach((node) => {
                    const nodeElement = document.getElementById(`node-${node.id}`);
                    let fillColor = "#e0e0e0";
                    if (node.id === "S") fillColor = "#ff9800";
                    else if (node.id === "T") fillColor = "#2196F3";
                    nodeElement.setAttribute("fill", fillColor);
                });
            };

            // Code toggle functionality
            document.getElementById("code-toggle").addEventListener("click", function () {
                const codeContent = document.getElementById("code-content");
                const toggle = document.getElementById("code-toggle");

                if (codeContent.classList.contains("collapsed")) {
                    codeContent.classList.remove("collapsed");
                    toggle.textContent = "Hide Code ▲";
                } else {
                    codeContent.classList.add("collapsed");
                    toggle.textContent = "Show Code ▼";
                }
            });

            // Helper sleep function
            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            // Initialize on load
            window.onload = function () {
                initGraph();
                loadCodeExample();
            };
        </script>
    </body>
</html>
