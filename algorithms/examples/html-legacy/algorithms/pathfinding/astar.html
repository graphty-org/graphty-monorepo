<!doctype html>
<html lang="en">
    <head>
        <!-- Eruda Mobile Console -->
        <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
        <script>
            if (typeof eruda !== "undefined") {
                eruda.init();
                if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
                    eruda.show();
                }
            }
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>A* Pathfinding - Simple Visual Explanation</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background: #f5f5f5;
            }

            h1 {
                color: #2c5aa0;
                text-align: center;
            }

            .container {
                background: white;
                border-radius: 8px;
                padding: 30px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            #graph {
                width: 100%;
                height: 400px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                margin: 20px 0;
            }

            button {
                background: #4caf50;
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 6px;
                cursor: pointer;
            }

            button:hover {
                background: #45a049;
            }

            button:disabled {
                background: #ccc;
                cursor: not-allowed;
            }

            .explanation {
                background: #e8f0fe;
                border-left: 4px solid #2c5aa0;
                padding: 15px;
                margin: 20px 0;
                border-radius: 4px;
            }

            .controls {
                text-align: center;
                margin: 20px 0;
            }

            .step-info {
                text-align: center;
                font-size: 18px;
                color: #333;
                margin: 20px 0;
                min-height: 30px;
            }

            .legend {
                display: flex;
                justify-content: center;
                gap: 20px;
                margin: 20px 0;
                flex-wrap: wrap;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .legend-circle {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid #333;
            }

            .start-node {
                background: #ff9800;
            }
            .goal-node {
                background: #f44336;
            }
            .exploring {
                background: #feca57;
            }
            .visited {
                background: #b2dfdb;
            }
            .path {
                background: #4caf50;
            }
            .unvisited {
                background: #e0e0e0;
            }

            .intro {
                text-align: center;
                color: #666;
                margin: 20px 0;
            }

            .score-display {
                background: #f0f0f0;
                padding: 15px;
                border-radius: 6px;
                margin: 20px 0;
                font-family: monospace;
            }

            .score-display h4 {
                margin: 0 0 10px 0;
                color: #666;
            }

            .back-link {
                color: #2c5aa0;
                text-decoration: none;
                margin-bottom: 20px;
                display: inline-block;
            }

            .back-link:hover {
                text-decoration: underline;
            }

            .code-section {
                margin-top: 30px;
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .code-toggle {
                background: #666;
                color: white;
                border: none;
                padding: 5px 10px;
                font-size: 12px;
                border-radius: 4px;
                cursor: pointer;
            }

            .code-content {
                overflow: hidden;
                transition: max-height 0.3s ease;
                max-height: 1000px;
            }

            .code-content.collapsed {
                max-height: 0;
            }

            .node-label {
                font-size: 11px;
                font-weight: bold;
            }

            .heuristic-label {
                font-size: 9px;
                fill: #666;
            }

            .grid-container {
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 20px;
                margin: 20px 0;
            }

            .grid-info {
                text-align: center;
                color: #666;
            }
        </style>
    </head>
    <body>
        <a href="../../index.html" class="back-link">← Back to Examples</a>

        <h1>A* Pathfinding Explained</h1>

        <div class="container">
            <div class="intro">
                <p><strong>A* finds the shortest path by being smart about which nodes to explore first.</strong></p>
                <p>Like a GPS navigator, it uses knowledge about the destination to guide its search efficiently.</p>
            </div>

            <svg id="graph"></svg>

            <div class="grid-info">
                <small>Grid representation: Each cell is a node, diagonal movement allowed</small>
            </div>

            <div class="score-display" id="score-display" style="display: none">
                <h4>Current Node Scores:</h4>
                <div id="score-content">
                    <div>f(n) = g(n) + h(n)</div>
                    <div>g(n) = Distance from start</div>
                    <div>h(n) = Estimated distance to goal (heuristic)</div>
                </div>
            </div>

            <div class="step-info" id="step-info">Click "Find Path" to see how A* navigates from start to goal</div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-circle start-node"></div>
                    <span>Start</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle goal-node"></div>
                    <span>Goal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle exploring"></div>
                    <span>Exploring</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle visited"></div>
                    <span>Visited</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle path"></div>
                    <span>Shortest Path</span>
                </div>
            </div>

            <div class="controls">
                <button id="find-btn" onclick="startPathfinding()">Find Path</button>
                <button id="reset-btn" onclick="resetVisualization()">Reset</button>
            </div>

            <div class="explanation">
                <h3>Key Concept:</h3>
                <p>A* is an intelligent pathfinding algorithm that combines the best of two worlds:</p>
                <ul>
                    <li><strong>Dijkstra's guarantee:</strong> Always finds the shortest path</li>
                    <li><strong>Greedy best-first efficiency:</strong> Uses a heuristic to search towards the goal</li>
                    <li><strong>f(n) = g(n) + h(n):</strong> Total cost = actual cost + estimated remaining cost</li>
                </ul>
                <p>
                    The heuristic function (h) estimates the distance to the goal. Common heuristics include Manhattan
                    distance for grids and Euclidean distance for open spaces.
                </p>
            </div>

            <div class="code-section">
                <div class="code-header">
                    <h3>Code Example</h3>
                    <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
                </div>
                <div class="code-content" id="code-content">
                    <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

        <script type="module">
            // Import the A* pathfinding function
            import { runAStarPathfinding } from "./astar.js";

            // Load and display the actual code
            async function loadCodeExample() {
                try {
                    const response = await fetch("./astar.js");
                    const code = await response.text();

                    // Extract the main function for display
                    const functionMatch = code.match(/export function runAStarPathfinding[\s\S]*?^}/m);
                    if (functionMatch) {
                        document.getElementById("code-display").textContent = functionMatch[0];
                        Prism.highlightElement(document.getElementById("code-display"));
                    } else {
                        document.getElementById("code-display").textContent = code;
                        Prism.highlightElement(document.getElementById("code-display"));
                    }
                } catch (error) {
                    document.getElementById("code-display").textContent = `// Example usage of A* pathfinding
import { astar } from '@graphty/algorithms';

// Create a graph with weighted edges
const graph = new Map([
    ['A', new Map([['B', 1], ['C', 4]])],
    ['B', new Map([['D', 2], ['E', 5]])],
    // ... more nodes
]);

// Define heuristic function (e.g., Euclidean distance)
function heuristic(node, goal) {
    // Return estimated distance to goal
}

// Find shortest path
const result = astar(graph, 'A', 'G', heuristic);
console.log('Path:', result.path);
console.log('Cost:', result.cost);`;
                    Prism.highlightElement(document.getElementById("code-display"));
                }
            }

            // Grid configuration
            const GRID_SIZE = 10;
            const CELL_SIZE = 35;
            const GRID_PADDING = 50;

            // Create grid nodes
            const nodes = [];
            const nodeMap = new Map();

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const id = `${x},${y}`;
                    const node = {
                        id,
                        x: GRID_PADDING + x * CELL_SIZE + CELL_SIZE / 2,
                        y: GRID_PADDING + y * CELL_SIZE + CELL_SIZE / 2,
                        gridX: x,
                        gridY: y,
                    };
                    nodes.push(node);
                    nodeMap.set(id, node);
                }
            }

            // Define start and goal
            const startId = "1,1";
            const goalId = "8,8";

            // Some obstacles for more interesting pathfinding
            const obstacles = new Set(["3,3", "3,4", "3,5", "4,3", "5,3", "6,3", "6,4", "6,5"]);

            let isRunning = false;
            let pathResult = null;

            // Initialize the graph visualization
            function initGraph() {
                const svg = document.getElementById("graph");
                svg.innerHTML = "";

                // Draw grid cells
                nodes.forEach((node) => {
                    if (!obstacles.has(node.id)) {
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", node.x - CELL_SIZE / 2);
                        rect.setAttribute("y", node.y - CELL_SIZE / 2);
                        rect.setAttribute("width", CELL_SIZE - 2);
                        rect.setAttribute("height", CELL_SIZE - 2);
                        rect.setAttribute(
                            "fill",
                            node.id === startId ? "#ff9800" : node.id === goalId ? "#f44336" : "#e0e0e0",
                        );
                        rect.setAttribute("stroke", "#999");
                        rect.setAttribute("stroke-width", "1");
                        rect.setAttribute("id", `cell-${node.id}`);
                        svg.appendChild(rect);

                        // Add label for start and goal
                        if (node.id === startId || node.id === goalId) {
                            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            text.setAttribute("x", node.x);
                            text.setAttribute("y", node.y + 4);
                            text.setAttribute("text-anchor", "middle");
                            text.setAttribute("class", "node-label");
                            text.setAttribute("fill", "white");
                            text.textContent = node.id === startId ? "S" : "G";
                            svg.appendChild(text);
                        }

                        // Add heuristic labels (will be shown during algorithm)
                        const hText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        hText.setAttribute("x", node.x);
                        hText.setAttribute("y", node.y - 8);
                        hText.setAttribute("text-anchor", "middle");
                        hText.setAttribute("class", "heuristic-label");
                        hText.setAttribute("id", `h-${node.id}`);
                        hText.style.visibility = "hidden";
                        svg.appendChild(hText);
                    } else {
                        // Draw obstacles
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", node.x - CELL_SIZE / 2);
                        rect.setAttribute("y", node.y - CELL_SIZE / 2);
                        rect.setAttribute("width", CELL_SIZE - 2);
                        rect.setAttribute("height", CELL_SIZE - 2);
                        rect.setAttribute("fill", "#666");
                        rect.setAttribute("stroke", "#333");
                        rect.setAttribute("stroke-width", "1");
                        svg.appendChild(rect);
                    }
                });
            }

            // Start the A* pathfinding visualization
            window.startPathfinding = async function () {
                if (isRunning) return;

                isRunning = true;
                document.getElementById("find-btn").disabled = true;
                document.getElementById("reset-btn").disabled = true;
                document.getElementById("score-display").style.display = "block";

                // Reset all non-obstacle cells
                nodes.forEach((node) => {
                    if (!obstacles.has(node.id) && node.id !== startId && node.id !== goalId) {
                        document.getElementById(`cell-${node.id}`).setAttribute("fill", "#e0e0e0");
                    }
                });

                // Run the actual algorithm
                const result = runAStarPathfinding(startId, goalId, obstacles);
                console.log("A* Pathfinding Result:", result);
                pathResult = result;

                // Animate the search process
                await animateSearch(result);

                isRunning = false;
                document.getElementById("reset-btn").disabled = false;
            };

            // Animate the A* search process
            async function animateSearch(result) {
                const stepInfo = document.getElementById("step-info");
                const scoreContent = document.getElementById("score-content");

                if (!result || !result.visited) {
                    stepInfo.textContent = "No path found!";
                    return;
                }

                // Show heuristic values
                nodes.forEach((node) => {
                    if (!obstacles.has(node.id)) {
                        const heuristic = Math.round(euclideanDistance(node, nodeMap.get(goalId)));
                        const hLabel = document.getElementById(`h-${node.id}`);
                        if (hLabel) {
                            hLabel.textContent = `h=${heuristic}`;
                            hLabel.style.visibility = "visible";
                        }
                    }
                });

                stepInfo.textContent = "Calculating heuristic values for all nodes...";
                await sleep(1000);

                // Animate visited nodes
                let visitCount = 0;
                for (const nodeId of result.visitedOrder) {
                    if (nodeId === startId || nodeId === goalId) continue;

                    visitCount++;
                    stepInfo.textContent = `Exploring node ${nodeId} (${visitCount} nodes visited)`;

                    const cell = document.getElementById(`cell-${nodeId}`);
                    if (cell) {
                        cell.setAttribute("fill", "#feca57"); // Exploring
                        await sleep(150);
                        cell.setAttribute("fill", "#b2dfdb"); // Visited
                    }

                    // Update score display
                    const g = result.gScores.get(nodeId) || 0;
                    const f = result.fScores.get(nodeId) || 0;
                    const h = f - g;
                    scoreContent.innerHTML = `
                    <div><strong>Current: ${nodeId}</strong></div>
                    <div>g(${nodeId}) = ${g.toFixed(1)} (distance from start)</div>
                    <div>h(${nodeId}) = ${h.toFixed(1)} (estimated to goal)</div>
                    <div>f(${nodeId}) = ${f.toFixed(1)} (total score)</div>
                `;
                }

                stepInfo.textContent = `Found goal! Visited ${visitCount} nodes. Showing shortest path...`;
                await sleep(1000);

                // Animate the final path
                if (result.path) {
                    for (let i = 1; i < result.path.length - 1; i++) {
                        const nodeId = result.path[i];
                        const cell = document.getElementById(`cell-${nodeId}`);
                        if (cell) {
                            cell.setAttribute("fill", "#4CAF50");
                            await sleep(200);
                        }
                    }

                    stepInfo.textContent = `Path found! Length: ${result.path.length - 1} steps, Cost: ${result.cost.toFixed(1)}`;
                    scoreContent.innerHTML = `
                    <div><strong>Path Complete!</strong></div>
                    <div>Total nodes visited: ${visitCount}</div>
                    <div>Path length: ${result.path.length - 1} steps</div>
                    <div>Path cost: ${result.cost.toFixed(1)}</div>
                    <div>Efficiency: ${(((result.path.length - 1) / visitCount) * 100).toFixed(1)}%</div>
                `;
                }
            }

            // Calculate Euclidean distance heuristic
            function euclideanDistance(nodeA, nodeB) {
                const dx = nodeA.gridX - nodeB.gridX;
                const dy = nodeA.gridY - nodeB.gridY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Reset the visualization
            window.resetVisualization = function () {
                document.getElementById("find-btn").disabled = false;
                document.getElementById("score-display").style.display = "none";
                document.getElementById("step-info").textContent =
                    'Click "Find Path" to see how A* navigates from start to goal';

                // Reset all cells
                nodes.forEach((node) => {
                    if (!obstacles.has(node.id)) {
                        const cell = document.getElementById(`cell-${node.id}`);
                        if (cell) {
                            cell.setAttribute(
                                "fill",
                                node.id === startId ? "#ff9800" : node.id === goalId ? "#f44336" : "#e0e0e0",
                            );
                        }

                        // Hide heuristic labels
                        const hLabel = document.getElementById(`h-${node.id}`);
                        if (hLabel) {
                            hLabel.style.visibility = "hidden";
                        }
                    }
                });
            };

            // Code toggle functionality
            document.getElementById("code-toggle").addEventListener("click", function () {
                const codeContent = document.getElementById("code-content");
                const toggle = document.getElementById("code-toggle");

                if (codeContent.classList.contains("collapsed")) {
                    codeContent.classList.remove("collapsed");
                    toggle.textContent = "Hide Code ▲";
                } else {
                    codeContent.classList.add("collapsed");
                    toggle.textContent = "Show Code ▼";
                }
            });

            // Helper sleep function
            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            // Initialize on load
            window.onload = function () {
                initGraph();
                loadCodeExample();
            };
        </script>
    </body>
</html>
