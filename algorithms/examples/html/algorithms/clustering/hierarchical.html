<!DOCTYPE html>
<html lang="en">
<head>
    <!-- MANDATORY: Eruda Mobile Console (exact code) -->
    <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
    <script>
      if (typeof eruda !== "undefined") {
        eruda.init();
        if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
          eruda.show();
        }
      }
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical Clustering - Simple Visual Explanation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <style>
        /* MANDATORY STYLES - DO NOT MODIFY */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5; /* Light gray background */
        }
        
        h1 {
            color: #2c5aa0; /* Blue header */
            text-align: center;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #graph {
            width: 100%;
            height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50; /* Green button */
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .explanation {
            background: #e8f0fe;
            border-left: 4px solid #2c5aa0;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        /* Additional algorithm-specific styles */
        .back-link {
            text-decoration: none;
            color: #2c5aa0;
            display: inline-block;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .intro {
            margin-bottom: 20px;
        }
        
        .intro p {
            margin: 10px 0;
            line-height: 1.6;
        }
        
        .intro strong {
            color: #333;
        }
        
        .clustering-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .clustering-stat {
            text-align: center;
            flex: 1;
            min-width: 150px;
        }
        
        .clustering-stat .value {
            font-size: 28px;
            font-weight: bold;
            color: #2c5aa0;
        }
        
        .clustering-stat .label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        
        .step-info {
            margin: 20px 0;
            padding: 15px;
            background: #f0f7ff;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .algorithm-settings {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }
        
        .setting-group label {
            font-size: 14px;
            color: #666;
        }
        
        .setting-group select,
        .setting-group input[type="range"] {
            width: 150px;
        }
        
        .setting-group span {
            font-weight: bold;
            color: #2c5aa0;
        }
        
        .explanation h3 {
            color: #2c5aa0;
            margin-top: 0;
        }
        
        .code-section {
            margin-top: 30px;
            border-top: 1px solid #e0e0e0;
            padding-top: 20px;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .code-header h3 {
            margin: 0;
            color: #2c5aa0;
        }
        
        .code-toggle {
            background: none;
            border: 1px solid #2c5aa0;
            color: #2c5aa0;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .code-toggle:hover {
            background: #2c5aa0;
            color: white;
        }
        
        .code-content {
            background: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .code-content.collapsed {
            max-height: 0;
        }
        
        pre {
            margin: 0;
            overflow-x: auto;
        }
        
        text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* Cluster colors */
        .cluster-0 { fill: #ff6b6b; }
        .cluster-1 { fill: #4ecdc4; }
        .cluster-2 { fill: #45b7d1; }
        .cluster-3 { fill: #f9ca24; }
        .cluster-4 { fill: #f0932b; }
        .cluster-5 { fill: #eb4d4b; }
        .cluster-6 { fill: #6ab04c; }
        .cluster-7 { fill: #130f40; }
        
        /* Merge animation */
        @keyframes merge {
            0% { opacity: 1; }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        .merging {
            animation: merge 1s ease-in-out;
        }
        
        #dendrogram {
            width: 100%;
            height: 200px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 20px 0;
            background: #fafafa;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">← Back to Examples</a>
    
    <h1>Hierarchical Clustering Explained</h1>
    
    <div class="container">
        <div class="intro">
            <p><strong>Like building a family tree - starts with individuals and groups them into larger families!</strong></p>
            <p>Hierarchical Clustering builds a tree of clusters by repeatedly merging the closest nodes or groups. It reveals the multi-scale structure of your network, from fine details to broad communities.</p>
        </div>
        
        <svg id="graph"></svg>
        
        <div class="clustering-info">
            <div class="clustering-stat">
                <div class="value" id="num-clusters">8</div>
                <div class="label">Current Clusters</div>
            </div>
            <div class="clustering-stat">
                <div class="value" id="merge-count">0</div>
                <div class="label">Merges Performed</div>
            </div>
            <div class="clustering-stat">
                <div class="value" id="current-height">0</div>
                <div class="label">Tree Height</div>
            </div>
        </div>
        
        <svg id="dendrogram"></svg>
        
        <div class="step-info" id="step-info">Click "Start" to see how Hierarchical Clustering works</div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #e0e0e0"></div>
                <span>Individual Nodes</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff9800"></div>
                <span>Being Merged</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4CAF50"></div>
                <span>Merged Cluster</span>
            </div>
        </div>
        
        <div class="algorithm-settings">
            <div class="setting-group">
                <label for="linkage-method">Linkage Method</label>
                <select id="linkage-method">
                    <option value="single">Single</option>
                    <option value="complete">Complete</option>
                    <option value="average" selected>Average</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="animation-speed">Animation Speed</label>
                <input type="range" id="animation-speed" min="500" max="3000" value="1500" step="100">
                <span id="speed-value">1.5s</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn" onclick="startAlgorithm()">Start Hierarchical Clustering</button>
        </div>
        
        <div class="explanation">
            <h3>Key Concept:</h3>
            <p>Hierarchical Clustering creates a tree (dendrogram) showing how nodes group together at different scales. Starting with each node as its own cluster, it repeatedly merges the closest pairs until all nodes are in one cluster.</p>
            <p>The linkage method determines how to measure distance between clusters: single (minimum), complete (maximum), or average distance between nodes.</p>
        </div>
        
        <div class="code-section">
            <div class="code-header">
                <h3>Code Example</h3>
                <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
            </div>
            <div class="code-content" id="code-content">
                <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    
    <script type="module">
        // Import the algorithm functions
        import { hierarchicalClustering, cutDendrogramKClusters } from './algorithms.js';
        
        // Cluster colors
        const clusterColors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', 
            '#f0932b', '#eb4d4b', '#6ab04c', '#130f40'
        ];
        
        // Load and display the actual code
        async function loadCodeExample() {
            try {
                const response = await fetch('./hierarchical.js');
                const code = await response.text();
                document.getElementById('code-display').textContent = code;
                Prism.highlightElement(document.getElementById('code-display'));
            } catch (error) {
                document.getElementById('code-display').textContent = 
`import { hierarchicalClustering, cutDendrogramKClusters } from '@graphty/algorithms';

// Create a graph with hierarchical structure
const graph = new Map([
    ['A', new Set(['B', 'C'])],
    ['B', new Set(['A', 'C'])],
    ['C', new Set(['A', 'B', 'D'])],
    ['D', new Set(['C', 'E'])],
    ['E', new Set(['D', 'F', 'G'])],
    ['F', new Set(['E', 'G'])],
    ['G', new Set(['E', 'F', 'H'])],
    ['H', new Set(['G'])]
]);

// Run Hierarchical Clustering
const result = hierarchicalClustering(graph, 'average');

console.log('Root cluster:', result.root);
console.log('Dendrogram nodes:', result.dendrogram.length);

// Cut dendrogram to get 3 clusters
const clusters = cutDendrogramKClusters(result.root, 3);
console.log('3 clusters:', clusters);`;
                Prism.highlightElement(document.getElementById('code-display'));
            }
        }
        
        // Graph structure for visualization - small hierarchical network
        const nodes = [
            {id: 'A', x: 100, y: 200},
            {id: 'B', x: 150, y: 150},
            {id: 'C', x: 200, y: 200},
            {id: 'D', x: 300, y: 200},
            {id: 'E', x: 400, y: 200},
            {id: 'F', x: 450, y: 150},
            {id: 'G', x: 500, y: 200},
            {id: 'H', x: 600, y: 200}
        ];
        
        const edges = [
            {source: 'A', target: 'B'},
            {source: 'A', target: 'C'},
            {source: 'B', target: 'C'},
            {source: 'C', target: 'D'},
            {source: 'D', target: 'E'},
            {source: 'E', target: 'F'},
            {source: 'E', target: 'G'},
            {source: 'F', target: 'G'},
            {source: 'G', target: 'H'}
        ];
        
        // Convert to adjacency list format for the algorithm
        function createGraph() {
            const graph = new Map();
            
            // Initialize all nodes
            nodes.forEach(node => {
                graph.set(node.id, new Set());
            });
            
            // Add edges (undirected)
            edges.forEach(edge => {
                graph.get(edge.source).add(edge.target);
                graph.get(edge.target).add(edge.source);
            });
            
            return graph;
        }
        
        // Animation state
        let isAnimating = false;
        let currentClusters = new Map();
        let animationSpeed = 1500;
        let dendrogramData = null;
        
        // Initialize graph visualization
        function initGraph() {
            const svg = document.getElementById('graph');
            
            // Clear existing content
            svg.innerHTML = '';
            
            // Draw edges
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.source);
                const targetNode = nodes.find(n => n.id === edge.target);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', sourceNode.x);
                line.setAttribute('y1', sourceNode.y);
                line.setAttribute('x2', targetNode.x);
                line.setAttribute('y2', targetNode.y);
                line.setAttribute('stroke', '#ccc');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            });
            
            // Draw nodes
            nodes.forEach((node, index) => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', '25');
                circle.setAttribute('fill', '#e0e0e0');
                circle.setAttribute('stroke', '#333');
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('id', `node-${node.id}`);
                circle.setAttribute('class', `cluster-${index}`);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y + 5);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '16');
                text.setAttribute('font-weight', 'bold');
                text.textContent = node.id;
                
                g.appendChild(circle);
                g.appendChild(text);
                svg.appendChild(g);
                
                // Initialize clusters
                currentClusters.set(node.id, index);
            });
            
            // Initialize dendrogram
            initDendrogram();
            
            // Initialize UI
            updateSpeedDisplay();
            loadCodeExample();
            
            // Code toggle functionality
            document.getElementById('code-toggle').addEventListener('click', function() {
                const codeContent = document.getElementById('code-content');
                const toggle = document.getElementById('code-toggle');
                
                if (codeContent.classList.contains('collapsed')) {
                    codeContent.classList.remove('collapsed');
                    codeContent.style.maxHeight = codeContent.scrollHeight + 'px';
                    toggle.textContent = 'Hide Code ▲';
                } else {
                    codeContent.classList.add('collapsed');
                    codeContent.style.maxHeight = '0';
                    toggle.textContent = 'Show Code ▼';
                }
            });
            
            // Initially show code
            const codeContent = document.getElementById('code-content');
            codeContent.style.maxHeight = codeContent.scrollHeight + 'px';
        }
        
        // Initialize dendrogram visualization
        function initDendrogram() {
            const svg = document.getElementById('dendrogram');
            svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999">Dendrogram will appear here</text>';
        }
        
        // Update speed display
        function updateSpeedDisplay() {
            const speed = document.getElementById('animation-speed').value;
            document.getElementById('speed-value').textContent = (speed / 1000).toFixed(1) + 's';
            animationSpeed = parseInt(speed);
        }
        
        // Event listener for settings
        document.getElementById('animation-speed').addEventListener('input', updateSpeedDisplay);
        
        // Visualize current clusters
        function visualizeClusters(clusterAssignments, message) {
            // Update node colors based on clusters
            clusterAssignments.forEach((clusterId, nodeId) => {
                const circle = document.getElementById(`node-${nodeId}`);
                if (circle) {
                    const clusterColor = clusterColors[clusterId % clusterColors.length];
                    circle.setAttribute('fill', clusterColor);
                }
            });
            
            // Count unique clusters
            const uniqueClusters = new Set(clusterAssignments.values());
            document.getElementById('num-clusters').textContent = uniqueClusters.size;
            
            // Update step info
            if (message) {
                document.getElementById('step-info').textContent = message;
            }
        }
        
        // Draw dendrogram
        function drawDendrogram(dendrogram, currentHeight) {
            const svg = document.getElementById('dendrogram');
            const width = svg.clientWidth;
            const height = svg.clientHeight;
            const margin = 20;
            
            svg.innerHTML = '';
            
            // Find leaf nodes and their positions
            const leafNodes = dendrogram.filter(node => !node.left && !node.right);
            const leafPositions = new Map();
            const leafSpacing = (width - 2 * margin) / (leafNodes.length - 1);
            
            leafNodes.forEach((node, i) => {
                const nodeId = Array.from(node.members)[0];
                leafPositions.set(nodeId, margin + i * leafSpacing);
            });
            
            // Calculate node positions
            const nodePositions = new Map();
            
            function calculatePosition(node) {
                if (!node.left && !node.right) {
                    // Leaf node
                    const nodeId = Array.from(node.members)[0];
                    return leafPositions.get(nodeId) || 0;
                } else {
                    // Internal node - average of children
                    const leftPos = calculatePosition(node.left);
                    const rightPos = calculatePosition(node.right);
                    return (leftPos + rightPos) / 2;
                }
            }
            
            // Draw dendrogram
            dendrogram.forEach(node => {
                const x = calculatePosition(node);
                const y = height - margin - (node.height / currentHeight) * (height - 2 * margin);
                nodePositions.set(node, {x, y});
                
                if (node.left && node.right) {
                    // Draw connections to children
                    const leftPos = nodePositions.get(node.left);
                    const rightPos = nodePositions.get(node.right);
                    
                    if (leftPos && rightPos) {
                        // Horizontal line
                        const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hLine.setAttribute('x1', leftPos.x);
                        hLine.setAttribute('y1', y);
                        hLine.setAttribute('x2', rightPos.x);
                        hLine.setAttribute('y2', y);
                        hLine.setAttribute('stroke', '#666');
                        hLine.setAttribute('stroke-width', '2');
                        svg.appendChild(hLine);
                        
                        // Vertical lines to children
                        const vLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        vLine1.setAttribute('x1', leftPos.x);
                        vLine1.setAttribute('y1', y);
                        vLine1.setAttribute('x2', leftPos.x);
                        vLine1.setAttribute('y2', leftPos.y);
                        vLine1.setAttribute('stroke', '#666');
                        vLine1.setAttribute('stroke-width', '2');
                        svg.appendChild(vLine1);
                        
                        const vLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        vLine2.setAttribute('x1', rightPos.x);
                        vLine2.setAttribute('y1', y);
                        vLine2.setAttribute('x2', rightPos.x);
                        vLine2.setAttribute('y2', rightPos.y);
                        vLine2.setAttribute('stroke', '#666');
                        vLine2.setAttribute('stroke-width', '2');
                        svg.appendChild(vLine2);
                    }
                }
                
                // Draw node
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', node.left ? '4' : '6');
                circle.setAttribute('fill', node.left ? '#666' : '#2c5aa0');
                svg.appendChild(circle);
                
                // Label for leaf nodes
                if (!node.left && !node.right) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', height - 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '12');
                    text.textContent = Array.from(node.members)[0];
                    svg.appendChild(text);
                }
            });
        }
        
        // Animate hierarchical clustering
        async function animateHierarchicalClustering() {
            const graph = createGraph();
            const linkage = document.getElementById('linkage-method').value;
            
            // Run the actual algorithm
            const result = hierarchicalClustering(graph, linkage);
            dendrogramData = result.dendrogram;
            
            // Initialize visualization
            const clusterAssignments = new Map();
            nodes.forEach((node, i) => clusterAssignments.set(node.id, i));
            
            visualizeClusters(clusterAssignments, 'Starting with each node as its own cluster...');
            drawDendrogram(result.dendrogram.slice(0, nodes.length), result.root.height);
            await new Promise(resolve => setTimeout(resolve, animationSpeed));
            
            // Animate merges
            let mergeCount = 0;
            const internalNodes = result.dendrogram.filter(node => node.left && node.right);
            
            for (const mergeNode of internalNodes) {
                mergeCount++;
                document.getElementById('merge-count').textContent = mergeCount;
                document.getElementById('current-height').textContent = mergeNode.height;
                
                // Find members to highlight
                const membersToMerge = Array.from(mergeNode.members);
                
                // Highlight nodes being merged
                membersToMerge.forEach(nodeId => {
                    const circle = document.getElementById(`node-${nodeId}`);
                    if (circle) {
                        circle.setAttribute('fill', '#ff9800');
                        circle.classList.add('merging');
                    }
                });
                
                document.getElementById('step-info').textContent = 
                    `Merging clusters containing ${membersToMerge.slice(0, 3).join(', ')}${membersToMerge.length > 3 ? '...' : ''}`;
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed));
                
                // Update cluster assignments
                const newClusterId = Math.min(...membersToMerge.map(id => clusterAssignments.get(id)));
                membersToMerge.forEach(nodeId => {
                    clusterAssignments.set(nodeId, newClusterId);
                });
                
                // Remove animation class
                membersToMerge.forEach(nodeId => {
                    const circle = document.getElementById(`node-${nodeId}`);
                    if (circle) {
                        circle.classList.remove('merging');
                    }
                });
                
                visualizeClusters(clusterAssignments, `Merged into cluster at height ${mergeNode.height}`);
                
                // Update dendrogram
                const visibleNodes = result.dendrogram.slice(0, nodes.length + mergeCount);
                drawDendrogram(visibleNodes, result.root.height);
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed / 2));
            }
            
            document.getElementById('step-info').textContent = 'Hierarchical clustering complete!';
        }
        
        // Start algorithm
        window.startAlgorithm = async function() {
            if (isAnimating) return;
            
            const button = document.getElementById('start-btn');
            button.disabled = true;
            button.textContent = 'Running...';
            isAnimating = true;
            
            try {
                // Reset display
                document.getElementById('num-clusters').textContent = nodes.length;
                document.getElementById('merge-count').textContent = '0';
                document.getElementById('current-height').textContent = '0';
                
                // Run actual algorithm for console output
                const graph = createGraph();
                const linkage = document.getElementById('linkage-method').value;
                const result = hierarchicalClustering(graph, linkage);
                console.log('Hierarchical Clustering Result:', result);
                
                // Get 3 clusters
                const clusters3 = cutDendrogramKClusters(result.root, 3);
                console.log('3 clusters:', clusters3);
                
                // Animate the algorithm
                await animateHierarchicalClustering();
                
            } finally {
                button.disabled = false;
                button.textContent = 'Start Hierarchical Clustering';
                isAnimating = false;
            }
        };
        
        // Initialize on load
        window.onload = initGraph;
    </script>
</body>
</html>