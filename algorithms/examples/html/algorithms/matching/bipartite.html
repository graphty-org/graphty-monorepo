<!DOCTYPE html>
<html lang="en">
<head>
    <!-- MANDATORY: Eruda Mobile Console (exact code) -->
    <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
    <script>
      if (typeof eruda !== "undefined") {
        eruda.init();
        if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
          eruda.show();
        }
      }
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bipartite Matching - Simple Visual Explanation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <style>
        /* MANDATORY STYLES - DO NOT MODIFY */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5; /* Light gray background */
        }
        
        h1 {
            color: #2c5aa0; /* Blue header */
            text-align: center;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #graph {
            width: 100%;
            height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50; /* Green button */
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .explanation {
            background: #e8f0fe;
            border-left: 4px solid #2c5aa0;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        /* Additional algorithm-specific styles */
        .back-link {
            text-decoration: none;
            color: #2c5aa0;
            display: inline-block;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .intro {
            margin-bottom: 20px;
        }
        
        .intro p {
            margin: 10px 0;
            line-height: 1.6;
        }
        
        .intro strong {
            color: #333;
        }
        
        .matching-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .matching-stat {
            text-align: center;
            flex: 1;
            min-width: 100px;
        }
        
        .matching-stat .value {
            font-size: 24px;
            font-weight: bold;
            color: #2c5aa0;
        }
        
        .matching-stat .label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        .step-info {
            margin: 20px 0;
            padding: 15px;
            background: #f0f7ff;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .algorithm-settings {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }
        
        .setting-group label {
            font-size: 14px;
            color: #666;
        }
        
        .setting-group select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .setting-group input[type="range"] {
            width: 120px;
        }
        
        .setting-group span {
            font-weight: bold;
            color: #2c5aa0;
            font-size: 12px;
        }
        
        .explanation h3 {
            color: #2c5aa0;
            margin-top: 0;
        }
        
        .code-section {
            margin-top: 30px;
            border-top: 1px solid #e0e0e0;
            padding-top: 20px;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .code-header h3 {
            margin: 0;
            color: #2c5aa0;
        }
        
        .code-toggle {
            background: none;
            border: 1px solid #2c5aa0;
            color: #2c5aa0;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .code-toggle:hover {
            background: #2c5aa0;
            color: white;
        }
        
        .code-content {
            background: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .code-content.collapsed {
            max-height: 0;
        }
        
        pre {
            margin: 0;
            overflow-x: auto;
        }
        
        text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* Bipartite-specific styles */
        .partition-left {
            fill: #e3f2fd;
            stroke: #1976d2;
            stroke-width: 2;
        }
        
        .partition-right {
            fill: #f3e5f5;
            stroke: #7b1fa2;
            stroke-width: 2;
        }
        
        .node-unmatched {
            fill: #e0e0e0;
            stroke: #666;
            stroke-width: 2;
        }
        
        .node-matched {
            fill: #4caf50;
            stroke: #2e7d32;
            stroke-width: 3;
        }
        
        .node-exploring {
            fill: #ff9800;
            stroke: #f57c00;
            stroke-width: 3;
        }
        
        .edge-available {
            stroke: #ddd;
            stroke-width: 2;
        }
        
        .edge-matched {
            stroke: #4caf50;
            stroke-width: 4;
        }
        
        .edge-exploring {
            stroke: #ff9800;
            stroke-width: 3;
            stroke-dasharray: 5,5;
        }
        
        .edge-augmenting {
            stroke: #f44336;
            stroke-width: 4;
            stroke-dasharray: 10,5;
        }
        
        .partition-label {
            font-size: 14px;
            font-weight: bold;
            fill: #666;
            text-anchor: middle;
        }
        
        /* Animation for augmenting path */
        @keyframes augment {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -20; }
        }
        
        .augmenting-animation {
            animation: augment 1s linear infinite;
        }
        
        .scenario-selector {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .scenario-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }
        
        .scenario-button {
            background: #2c5aa0;
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .scenario-button:hover {
            background: #1976d2;
        }
        
        .scenario-button.active {
            background: #4caf50;
        }
        
        .matching-results {
            background: #e8f5e8;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .matching-results.show {
            display: block;
        }
        
        .matching-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
        }
        
        .matching-item:last-child {
            border-bottom: none;
        }
        
        .matching-arrow {
            color: #4caf50;
            font-weight: bold;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">← Back to Examples</a>
    
    <h1>Bipartite Matching Explained</h1>
    
    <div class="container">
        <div class="intro">
            <p><strong>Like perfect job assignments - each worker gets one job, each job gets one worker!</strong></p>
            <p>Bipartite Matching finds the maximum number of connections between two separate groups where each element can only be matched once. Think hiring the most workers possible when each has specific qualifications.</p>
        </div>
        
        <div class="scenario-selector">
            <strong>Choose a Scenario:</strong>
            <div class="scenario-buttons">
                <button class="scenario-button active" onclick="loadScenario('jobs')">Job Assignment</button>
                <button class="scenario-button" onclick="loadScenario('dating')">Dating App</button>
                <button class="scenario-button" onclick="loadScenario('scheduling')">Course Scheduling</button>
                <button class="scenario-button" onclick="loadScenario('projects')">Project Assignment</button>
            </div>
        </div>
        
        <svg id="graph"></svg>
        
        <div class="matching-info">
            <div class="matching-stat">
                <div class="value" id="left-count">0</div>
                <div class="label">Left Partition</div>
            </div>
            <div class="matching-stat">
                <div class="value" id="right-count">0</div>
                <div class="label">Right Partition</div>
            </div>
            <div class="matching-stat">
                <div class="value" id="matching-size">0</div>
                <div class="label">Matches Found</div>
            </div>
            <div class="matching-stat">
                <div class="value" id="efficiency">0%</div>
                <div class="label">Efficiency</div>
            </div>
        </div>
        
        <div class="matching-results" id="matching-results">
            <h4>Matching Results:</h4>
            <div id="matching-list"></div>
        </div>
        
        <div class="step-info" id="step-info">Click "Start" to find maximum bipartite matching</div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #e3f2fd; border-color: #1976d2;"></div>
                <span>Left Partition</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f3e5f5; border-color: #7b1fa2;"></div>
                <span>Right Partition</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4caf50; border-color: #2e7d32;"></div>
                <span>Matched</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff9800; border-color: #f57c00;"></div>
                <span>Exploring</span>
            </div>
        </div>
        
        <div class="algorithm-settings">
            <div class="setting-group">
                <label for="algorithm-type">Algorithm</label>
                <select id="algorithm-type">
                    <option value="maximum">Maximum Matching</option>
                    <option value="greedy">Greedy Matching</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="animation-speed">Animation Speed</label>
                <input type="range" id="animation-speed" min="500" max="3000" value="1500" step="100">
                <span id="speed-value">1.5s</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn" onclick="startAlgorithm()">Start Bipartite Matching</button>
            <button id="reset-btn" onclick="resetVisualization()">Reset</button>
        </div>
        
        <div class="explanation">
            <h3>Key Concept:</h3>
            <p>Bipartite Matching solves assignment problems where:</p>
            <p><strong>1. Two separate groups:</strong> No connections within a group (workers can't be assigned to workers)</p>
            <p><strong>2. Each element matched at most once:</strong> One worker per job, one job per worker</p>
            <p><strong>3. Maximum assignment:</strong> Find the largest possible number of valid assignments</p>
            <p>The algorithm uses <strong>augmenting paths</strong> - it finds paths that can improve the current matching by reassigning existing matches to create space for new ones!</p>
        </div>
        
        <div class="code-section">
            <div class="code-header">
                <h3>Code Example</h3>
                <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
            </div>
            <div class="code-content" id="code-content">
                <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    
    <script type="module">
        // Import the algorithm functions
        import { Graph } from './algorithms.js';
        import { maximumBipartiteMatching, greedyBipartiteMatching, bipartitePartition } from './algorithms.js';
        
        // Load and display the actual code
        async function loadCodeExample() {
            try {
                const response = await fetch('./bipartite.js');
                const code = await response.text();
                document.getElementById('code-display').textContent = code;
                Prism.highlightElement(document.getElementById('code-display'));
            } catch (error) {
                document.getElementById('code-display').textContent = 
`import { Graph, maximumBipartiteMatching, bipartitePartition } from '@graphty/algorithms';

// Create a job assignment bipartite graph
const graph = new Graph();

// Workers (left partition)
const workers = ['Alice', 'Bob', 'Charlie', 'David'];
const jobs = ['Frontend', 'Backend', 'Database', 'DevOps'];

// Add edges representing qualifications
graph.addEdge('Alice', 'Frontend');
graph.addEdge('Alice', 'Database');
graph.addEdge('Bob', 'Backend');
graph.addEdge('Bob', 'DevOps');
graph.addEdge('Charlie', 'Frontend');
graph.addEdge('Charlie', 'Backend');
graph.addEdge('David', 'Database');
graph.addEdge('David', 'DevOps');

// Check if graph is bipartite
const partition = bipartitePartition(graph);
console.log('Left partition:', partition.left);
console.log('Right partition:', partition.right);

// Find maximum matching
const result = maximumBipartiteMatching(graph);
console.log('Maximum matching size:', result.size);
console.log('Assignments:', result.matching);`;
                Prism.highlightElement(document.getElementById('code-display'));
            }
        }
        
        // Different scenarios
        const scenarios = {
            jobs: {
                name: "Job Assignment",
                left: ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
                right: ['Frontend', 'Backend', 'Database', 'DevOps', 'Testing'],
                edges: [
                    ['Alice', 'Frontend'], ['Alice', 'Testing'],
                    ['Bob', 'Backend'], ['Bob', 'Database'],
                    ['Charlie', 'Frontend'], ['Charlie', 'Backend'],
                    ['David', 'Database'], ['David', 'DevOps'],
                    ['Eve', 'DevOps'], ['Eve', 'Testing']
                ],
                leftLabel: "Workers",
                rightLabel: "Jobs"
            },
            dating: {
                name: "Dating App",
                left: ['Alex', 'Blake', 'Casey', 'Drew'],
                right: ['Jordan', 'Morgan', 'Pat', 'Sam', 'Taylor'],
                edges: [
                    ['Alex', 'Jordan'], ['Alex', 'Pat'],
                    ['Blake', 'Morgan'], ['Blake', 'Pat'], ['Blake', 'Sam'],
                    ['Casey', 'Jordan'], ['Casey', 'Sam'], ['Casey', 'Taylor'],
                    ['Drew', 'Morgan'], ['Drew', 'Taylor']
                ],
                leftLabel: "Group A",
                rightLabel: "Group B"
            },
            scheduling: {
                name: "Course Scheduling",
                left: ['Student1', 'Student2', 'Student3', 'Student4', 'Student5'],
                right: ['Mon9AM', 'Mon2PM', 'Tue9AM', 'Tue2PM', 'Wed9AM', 'Wed2PM'],
                edges: [
                    ['Student1', 'Mon9AM'], ['Student1', 'Tue9AM'], ['Student1', 'Wed9AM'],
                    ['Student2', 'Mon9AM'], ['Student2', 'Mon2PM'], ['Student2', 'Tue2PM'],
                    ['Student3', 'Tue9AM'], ['Student3', 'Tue2PM'], ['Student3', 'Wed2PM'],
                    ['Student4', 'Mon2PM'], ['Student4', 'Wed9AM'], ['Student4', 'Wed2PM'],
                    ['Student5', 'Mon9AM'], ['Student5', 'Tue2PM'], ['Student5', 'Wed9AM']
                ],
                leftLabel: "Students",
                rightLabel: "Time Slots"
            },
            projects: {
                name: "Project Assignment",
                left: ['Dev1', 'Dev2', 'Dev3', 'Dev4'],
                right: ['ProjectA', 'ProjectB', 'ProjectC', 'ProjectD'],
                edges: [
                    ['Dev1', 'ProjectA'], ['Dev1', 'ProjectC'],
                    ['Dev2', 'ProjectB'], ['Dev2', 'ProjectD'],
                    ['Dev3', 'ProjectA'], ['Dev3', 'ProjectB'], ['Dev3', 'ProjectC'],
                    ['Dev4', 'ProjectC'], ['Dev4', 'ProjectD']
                ],
                leftLabel: "Developers",
                rightLabel: "Projects"
            }
        };
        
        // Current state
        let currentScenario = 'jobs';
        let isAnimating = false;
        let animationSpeed = 1500;
        let currentMatching = new Map();
        
        // Load scenario
        window.loadScenario = function(scenarioName) {
            if (isAnimating) return;
            
            currentScenario = scenarioName;
            
            // Update button states
            document.querySelectorAll('.scenario-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Reset and reload
            resetVisualization();
            initGraph();
        };
        
        // Create graph for current scenario
        function createGraph() {
            const scenario = scenarios[currentScenario];
            const graph = new Graph();
            
            // Add nodes
            scenario.left.forEach(node => graph.addNode(node));
            scenario.right.forEach(node => graph.addNode(node));
            
            // Add edges
            scenario.edges.forEach(([source, target]) => {
                graph.addEdge(source, target);
            });
            
            return graph;
        }
        
        // Initialize graph visualization
        function initGraph() {
            const svg = document.getElementById('graph');
            const scenario = scenarios[currentScenario];
            
            // Clear existing content
            svg.innerHTML = '';
            
            // Set up layout
            const leftX = 150;
            const rightX = 450;
            const startY = 80;
            const nodeSpacing = 60;
            
            // Add partition labels
            const leftLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            leftLabel.setAttribute('x', leftX);
            leftLabel.setAttribute('y', 30);
            leftLabel.setAttribute('class', 'partition-label');
            leftLabel.textContent = scenario.leftLabel;
            svg.appendChild(leftLabel);
            
            const rightLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            rightLabel.setAttribute('x', rightX);
            rightLabel.setAttribute('y', 30);
            rightLabel.setAttribute('class', 'partition-label');
            rightLabel.textContent = scenario.rightLabel;
            svg.appendChild(rightLabel);
            
            // Draw edges first (so they appear behind nodes)
            scenario.edges.forEach((edge, index) => {
                const leftIndex = scenario.left.indexOf(edge[0]);
                const rightIndex = scenario.right.indexOf(edge[1]);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', leftX);
                line.setAttribute('y1', startY + leftIndex * nodeSpacing);
                line.setAttribute('x2', rightX);
                line.setAttribute('y2', startY + rightIndex * nodeSpacing);
                line.setAttribute('class', 'edge-available');
                line.setAttribute('id', `edge-${edge[0]}-${edge[1]}`);
                svg.appendChild(line);
            });
            
            // Draw left partition nodes
            scenario.left.forEach((node, index) => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftX);
                circle.setAttribute('cy', startY + index * nodeSpacing);
                circle.setAttribute('r', '25');
                circle.setAttribute('class', 'partition-left node-unmatched');
                circle.setAttribute('id', `node-${node}`);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftX);
                text.setAttribute('y', startY + index * nodeSpacing + 5);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.textContent = node;
                
                g.appendChild(circle);
                g.appendChild(text);
                svg.appendChild(g);
            });
            
            // Draw right partition nodes
            scenario.right.forEach((node, index) => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', rightX);
                circle.setAttribute('cy', startY + index * nodeSpacing);
                circle.setAttribute('r', '25');
                circle.setAttribute('class', 'partition-right node-unmatched');
                circle.setAttribute('id', `node-${node}`);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', rightX);
                text.setAttribute('y', startY + index * nodeSpacing + 5);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.textContent = node;
                
                g.appendChild(circle);
                g.appendChild(text);
                svg.appendChild(g);
            });
            
            // Update stats
            document.getElementById('left-count').textContent = scenario.left.length;
            document.getElementById('right-count').textContent = scenario.right.length;
            document.getElementById('matching-size').textContent = '0';
            document.getElementById('efficiency').textContent = '0%';
            
            // Initialize UI
            updateSettings();
            loadCodeExample();
            
            // Code toggle functionality
            document.getElementById('code-toggle').addEventListener('click', function() {
                const codeContent = document.getElementById('code-content');
                const toggle = document.getElementById('code-toggle');
                
                if (codeContent.classList.contains('collapsed')) {
                    codeContent.classList.remove('collapsed');
                    codeContent.style.maxHeight = codeContent.scrollHeight + 'px';
                    toggle.textContent = 'Hide Code ▲';
                } else {
                    codeContent.classList.add('collapsed');
                    codeContent.style.maxHeight = '0';
                    toggle.textContent = 'Show Code ▼';
                }
            });
            
            // Initially show code
            const codeContent = document.getElementById('code-content');
            codeContent.style.maxHeight = codeContent.scrollHeight + 'px';
        }
        
        // Update settings displays
        function updateSettings() {
            const speed = document.getElementById('animation-speed').value;
            document.getElementById('speed-value').textContent = (speed / 1000).toFixed(1) + 's';
            animationSpeed = parseInt(speed);
        }
        
        // Event listeners for settings
        document.getElementById('animation-speed').addEventListener('input', updateSettings);
        
        // Animate matching algorithm
        async function animateMatching() {
            const graph = createGraph();
            const scenario = scenarios[currentScenario];
            const isGreedy = document.getElementById('algorithm-type').value === 'greedy';
            
            document.getElementById('step-info').textContent = 
                `Starting ${isGreedy ? 'Greedy' : 'Maximum'} Bipartite Matching...`;
            
            await new Promise(resolve => setTimeout(resolve, animationSpeed));
            
            if (isGreedy) {
                // Animate greedy algorithm
                await animateGreedyMatching(graph, scenario);
            } else {
                // Animate maximum matching algorithm
                await animateMaximumMatching(graph, scenario);
            }
        }
        
        // Animate greedy matching
        async function animateGreedyMatching(graph, scenario) {
            document.getElementById('step-info').textContent = 'Greedy approach: Match first available connection for each left node...';
            await new Promise(resolve => setTimeout(resolve, animationSpeed));
            
            const matched = new Set();
            
            for (const leftNode of scenario.left) {
                // Highlight current node
                const nodeElement = document.getElementById(`node-${leftNode}`);
                nodeElement.classList.add('node-exploring');
                
                document.getElementById('step-info').textContent = `Looking for available match for ${leftNode}...`;
                await new Promise(resolve => setTimeout(resolve, animationSpeed));
                
                // Find first available neighbor
                const neighbors = Array.from(graph.neighbors(leftNode));
                let foundMatch = false;
                
                for (const rightNode of neighbors) {
                    if (scenario.right.includes(rightNode) && !matched.has(rightNode)) {
                        // Found a match!
                        currentMatching.set(leftNode, rightNode);
                        matched.add(rightNode);
                        foundMatch = true;
                        
                        // Update visual
                        const leftNodeElement = document.getElementById(`node-${leftNode}`);
                        const rightNodeElement = document.getElementById(`node-${rightNode}`);
                        const edgeElement = document.getElementById(`edge-${leftNode}-${rightNode}`);
                        
                        leftNodeElement.classList.remove('node-exploring');
                        leftNodeElement.classList.add('node-matched');
                        rightNodeElement.classList.add('node-matched');
                        edgeElement.classList.add('edge-matched');
                        
                        document.getElementById('step-info').textContent = `Matched ${leftNode} → ${rightNode}`;
                        break;
                    }
                }
                
                if (!foundMatch) {
                    nodeElement.classList.remove('node-exploring');
                    document.getElementById('step-info').textContent = `No available match for ${leftNode}`;
                }
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed));
            }
        }
        
        // Animate maximum matching (simplified visualization)
        async function animateMaximumMatching(graph, scenario) {
            document.getElementById('step-info').textContent = 'Maximum Matching: Finding optimal assignment using augmenting paths...';
            await new Promise(resolve => setTimeout(resolve, animationSpeed));
            
            // Get the actual result
            const result = maximumBipartiteMatching(graph);
            
            // Simulate the process with visual feedback
            let step = 1;
            for (const [leftNode, rightNode] of result.matching.entries()) {
                document.getElementById('step-info').textContent = 
                    `Step ${step}: Found augmenting path for ${leftNode} → ${rightNode}`;
                
                // Highlight the path
                const leftNodeElement = document.getElementById(`node-${leftNode}`);
                const rightNodeElement = document.getElementById(`node-${rightNode}`);
                const edgeElement = document.getElementById(`edge-${leftNode}-${rightNode}`);
                
                leftNodeElement.classList.add('node-exploring');
                rightNodeElement.classList.add('node-exploring');
                edgeElement.classList.add('edge-augmenting', 'augmenting-animation');
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed));
                
                // Confirm the match
                leftNodeElement.classList.remove('node-exploring');
                rightNodeElement.classList.remove('node-exploring');
                leftNodeElement.classList.add('node-matched');
                rightNodeElement.classList.add('node-matched');
                edgeElement.classList.remove('edge-augmenting', 'augmenting-animation');
                edgeElement.classList.add('edge-matched');
                
                currentMatching.set(leftNode, rightNode);
                step++;
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed / 2));
            }
        }
        
        // Display final results
        function displayResults() {
            const scenario = scenarios[currentScenario];
            const matchingSize = currentMatching.size;
            const efficiency = ((matchingSize / Math.min(scenario.left.length, scenario.right.length)) * 100).toFixed(0);
            
            document.getElementById('matching-size').textContent = matchingSize;
            document.getElementById('efficiency').textContent = `${efficiency}%`;
            
            // Show matching results
            const resultsList = document.getElementById('matching-list');
            resultsList.innerHTML = '';
            
            currentMatching.forEach((rightNode, leftNode) => {
                const item = document.createElement('div');
                item.className = 'matching-item';
                item.innerHTML = `
                    <span>${leftNode}</span>
                    <span class="matching-arrow">→</span>
                    <span>${rightNode}</span>
                `;
                resultsList.appendChild(item);
            });
            
            const unmatchedLeft = scenario.left.filter(node => !currentMatching.has(node));
            const matchedRight = new Set(currentMatching.values());
            const unmatchedRight = scenario.right.filter(node => !matchedRight.has(node));
            
            if (unmatchedLeft.length > 0 || unmatchedRight.length > 0) {
                const unmatchedItem = document.createElement('div');
                unmatchedItem.style.marginTop = '10px';
                unmatchedItem.style.fontSize = '14px';
                unmatchedItem.style.color = '#666';
                unmatchedItem.innerHTML = `
                    Unmatched: ${unmatchedLeft.concat(unmatchedRight).join(', ') || 'None'}
                `;
                resultsList.appendChild(unmatchedItem);
            }
            
            document.getElementById('matching-results').classList.add('show');
            document.getElementById('step-info').textContent = 
                `Bipartite matching complete! Found ${matchingSize} matches with ${efficiency}% efficiency.`;
        }
        
        // Reset visualization
        window.resetVisualization = function() {
            if (isAnimating) return;
            
            const scenario = scenarios[currentScenario];
            currentMatching.clear();
            
            // Reset node colors
            [...scenario.left, ...scenario.right].forEach(node => {
                const nodeElement = document.getElementById(`node-${node}`);
                nodeElement.classList.remove('node-matched', 'node-exploring');
                nodeElement.classList.add('node-unmatched');
            });
            
            // Reset edge colors
            scenario.edges.forEach(([source, target]) => {
                const edgeElement = document.getElementById(`edge-${source}-${target}`);
                edgeElement.classList.remove('edge-matched', 'edge-exploring', 'edge-augmenting', 'augmenting-animation');
                edgeElement.classList.add('edge-available');
            });
            
            // Reset displays
            document.getElementById('matching-size').textContent = '0';
            document.getElementById('efficiency').textContent = '0%';
            document.getElementById('matching-results').classList.remove('show');
            document.getElementById('step-info').textContent = 'Click "Start" to find maximum bipartite matching';
        };
        
        // Start algorithm
        window.startAlgorithm = async function() {
            if (isAnimating) return;
            
            const button = document.getElementById('start-btn');
            button.disabled = true;
            button.textContent = 'Running...';
            isAnimating = true;
            
            try {
                resetVisualization();
                
                // Run actual algorithm for console output
                const graph = createGraph();
                const isGreedy = document.getElementById('algorithm-type').value === 'greedy';
                
                const result = isGreedy ? 
                    greedyBipartiteMatching(graph) : 
                    maximumBipartiteMatching(graph);
                    
                console.log(`${isGreedy ? 'Greedy' : 'Maximum'} Bipartite Matching Result:`, result);
                
                // Animate the algorithm
                await animateMatching();
                displayResults();
                
            } finally {
                button.disabled = false;
                button.textContent = 'Start Bipartite Matching';
                isAnimating = false;
            }
        };
        
        // Initialize on load
        window.onload = initGraph;
    </script>
</body>
</html>