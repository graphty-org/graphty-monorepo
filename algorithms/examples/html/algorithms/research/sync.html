<!doctype html>
<html lang="en">
    <head>
        <!-- MANDATORY: Eruda Mobile Console (exact code) -->
        <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
        <script>
            if (typeof eruda !== "undefined") {
                eruda.init();
                if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
                    eruda.show();
                }
            }
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>SynC Algorithm - Simple Visual Explanation</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
        <style>
            /* MANDATORY STYLES - DO NOT MODIFY */
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background: #f5f5f5; /* Light gray background */
            }

            h1 {
                color: #2c5aa0; /* Blue header */
                text-align: center;
            }

            .container {
                background: white;
                border-radius: 8px;
                padding: 30px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            #graph {
                width: 100%;
                height: 400px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                margin: 20px 0;
            }

            button {
                background: #4caf50; /* Green button */
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 6px;
                cursor: pointer;
            }

            .explanation {
                background: #e8f0fe;
                border-left: 4px solid #2c5aa0;
                padding: 15px;
                margin: 20px 0;
                border-radius: 4px;
            }

            /* Additional algorithm-specific styles */
            .back-link {
                text-decoration: none;
                color: #2c5aa0;
                display: inline-block;
                margin-bottom: 20px;
                font-weight: 500;
            }

            .back-link:hover {
                text-decoration: underline;
            }

            .intro {
                margin-bottom: 20px;
            }

            .intro p {
                margin: 10px 0;
                line-height: 1.6;
            }

            .intro strong {
                color: #333;
            }

            .scenario-selector {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin: 20px 0;
            }

            .scenario-btn {
                background: #e8f0fe;
                color: #2c5aa0;
                border: 1px solid #2c5aa0;
                padding: 8px 16px;
                font-size: 14px;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .scenario-btn:hover {
                background: #2c5aa0;
                color: white;
            }

            .scenario-btn.active {
                background: #2c5aa0;
                color: white;
            }

            .parameter-controls {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin: 20px 0;
                padding: 15px;
                background: #f8f9fa;
                border-radius: 6px;
            }

            .parameter-group {
                display: flex;
                flex-direction: column;
            }

            .parameter-group label {
                font-weight: 500;
                margin-bottom: 5px;
                color: #333;
            }

            .parameter-group input[type="range"] {
                margin-bottom: 5px;
            }

            .parameter-group .value-display {
                font-size: 12px;
                color: #666;
                text-align: center;
            }

            .step-info {
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                border-radius: 4px;
                padding: 10px;
                margin: 10px 0;
                text-align: center;
                font-weight: 500;
            }

            .legend {
                display: flex;
                justify-content: center;
                gap: 20px;
                margin: 15px 0;
                font-size: 14px;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 5px;
            }

            .legend-color {
                width: 12px;
                height: 12px;
                border-radius: 2px;
            }

            .controls {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin: 20px 0;
            }

            .embedding-viz {
                margin: 20px 0;
                border: 1px solid #e0e0e0;
                border-radius: 6px;
                padding: 15px;
                background: #fafafa;
            }

            .embedding-viz h4 {
                margin: 0 0 10px 0;
                color: #2c5aa0;
            }

            #embedding-chart {
                width: 100%;
                height: 200px;
                border: 1px solid #ddd;
                border-radius: 4px;
                background: white;
            }

            .convergence-info {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin: 15px 0;
                font-size: 14px;
            }

            .convergence-metric {
                background: #e8f5e8;
                padding: 8px;
                border-radius: 4px;
                text-align: center;
            }

            .convergence-metric .label {
                font-weight: 500;
                color: #2e7d32;
            }

            .convergence-metric .value {
                font-size: 16px;
                color: #1b5e20;
            }

            .code-section {
                margin-top: 30px;
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .code-header h3 {
                margin: 0;
                color: #2c5aa0;
            }

            .code-toggle {
                background: #f0f0f0;
                color: #333;
                border: 1px solid #ccc;
                padding: 6px 12px;
                font-size: 12px;
                border-radius: 4px;
                cursor: pointer;
            }

            .code-content {
                max-height: 400px;
                overflow-y: auto;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
            }

            .code-content pre {
                margin: 0;
                padding: 15px;
            }

            .algorithm-step {
                margin: 10px 0;
                padding: 10px;
                border-left: 3px solid #4caf50;
                background: #f1f8e9;
                border-radius: 0 4px 4px 0;
            }

            .algorithm-step.active {
                border-left-color: #ff9800;
                background: #fff3e0;
            }
        </style>
    </head>
    <body>
        <a href="../../index.html" class="back-link">‚Üê Back to Examples</a>

        <h1>SynC (Synergistic Deep Graph Clustering) Explained</h1>

        <div class="container">
            <div class="intro">
                <p><strong>SynC is like a smart chef who learns recipes while organizing ingredients.</strong></p>
                <p>
                    It simultaneously learns node representations (like understanding ingredient properties) and groups
                    them into clusters (like organizing ingredients by recipe), creating a synergistic effect where each
                    process improves the other.
                </p>
            </div>

            <div class="scenario-selector">
                <button class="scenario-btn active" onclick="loadScenario('social')">Social Network</button>
                <button class="scenario-btn" onclick="loadScenario('research')">Research Groups</button>
                <button class="scenario-btn" onclick="loadScenario('protein')">Protein Modules</button>
                <button class="scenario-btn" onclick="loadScenario('technology')">Tech Companies</button>
            </div>

            <div class="parameter-controls">
                <div class="parameter-group">
                    <label for="clusters-slider">Number of Clusters</label>
                    <input type="range" id="clusters-slider" min="2" max="6" value="3" />
                    <div class="value-display" id="clusters-value">3</div>
                </div>
                <div class="parameter-group">
                    <label for="learning-rate-slider">Learning Rate</label>
                    <input type="range" id="learning-rate-slider" min="0.001" max="0.1" step="0.001" value="0.01" />
                    <div class="value-display" id="learning-rate-value">0.01</div>
                </div>
                <div class="parameter-group">
                    <label for="lambda-slider">Regularization (Œª)</label>
                    <input type="range" id="lambda-slider" min="0.01" max="1.0" step="0.01" value="0.1" />
                    <div class="value-display" id="lambda-value">0.1</div>
                </div>
                <div class="parameter-group">
                    <label for="seed-slider">Random Seed</label>
                    <input type="range" id="seed-slider" min="1" max="100" value="42" />
                    <div class="value-display" id="seed-value">42</div>
                </div>
            </div>

            <svg id="graph"></svg>

            <div class="step-info" id="step-info">Click "Start SynC" to see how synergistic deep clustering works</div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #e0e0e0"></div>
                    <span>Unclustered</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800"></div>
                    <span>Processing</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4caf50"></div>
                    <span>Cluster 1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196f3"></div>
                    <span>Cluster 2</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9c27b0"></div>
                    <span>Cluster 3+</span>
                </div>
            </div>

            <div class="convergence-info" id="convergence-info" style="display: none">
                <div class="convergence-metric">
                    <div class="label">Iterations</div>
                    <div class="value" id="iterations-value">0</div>
                </div>
                <div class="convergence-metric">
                    <div class="label">Loss</div>
                    <div class="value" id="loss-value">0.000</div>
                </div>
                <div class="convergence-metric">
                    <div class="label">Converged</div>
                    <div class="value" id="converged-value">No</div>
                </div>
                <div class="convergence-metric">
                    <div class="label">Final Clusters</div>
                    <div class="value" id="final-clusters-value">0</div>
                </div>
            </div>

            <div class="embedding-viz">
                <h4>Node Embeddings Evolution</h4>
                <svg id="embedding-chart"></svg>
            </div>

            <div class="controls">
                <button id="start-btn" onclick="startAlgorithm()">Start SynC</button>
                <button id="step-btn" onclick="stepAlgorithm()" disabled>Step</button>
                <button id="reset-btn" onclick="resetVisualization()">Reset</button>
            </div>

            <div class="explanation">
                <h3>Key Concept:</h3>
                <p>
                    <strong>Synergistic Learning:</strong> SynC combines representation learning (understanding node
                    features) with clustering (grouping similar nodes) in a joint optimization process. As the algorithm
                    learns better representations, clustering improves, and better clusters help learn more meaningful
                    representations.
                </p>
                <p>
                    <strong>Deep Integration:</strong> Unlike traditional clustering that works on fixed features, SynC
                    dynamically adapts node embeddings based on both local graph structure and global clustering
                    objectives.
                </p>
            </div>

            <div class="algorithm-step">
                <strong>Step 1: Initialize</strong> - Create random node embeddings and cluster centers
            </div>
            <div class="algorithm-step">
                <strong>Step 2: Assign</strong> - Assign each node to nearest cluster center in embedding space
            </div>
            <div class="algorithm-step">
                <strong>Step 3: Update Embeddings</strong> - Adjust embeddings to preserve graph structure and improve
                clustering
            </div>
            <div class="algorithm-step">
                <strong>Step 4: Update Centers</strong> - Recalculate cluster centers based on new assignments
            </div>
            <div class="algorithm-step">
                <strong>Step 5: Repeat</strong> - Continue until convergence or maximum iterations
            </div>

            <div class="code-section">
                <div class="code-header">
                    <h3>Code Example</h3>
                    <button class="code-toggle" id="code-toggle">Hide Code ‚ñ≤</button>
                </div>
                <div class="code-content" id="code-content">
                    <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

        <script type="module">
            import { syncClustering } from "./algorithms.js";
            import { runAllSynCTests } from "./sync.js";

            // Load and display the actual code
            async function loadCodeExample() {
                try {
                    const response = await fetch("./sync.js");
                    const code = await response.text();
                    const codeDisplay = document.getElementById("code-display");
                    codeDisplay.textContent = code;
                    Prism.highlightElement(codeDisplay);
                } catch (error) {
                    console.error("Error loading code example:", error);
                    document.getElementById("code-display").textContent = "Error loading code example.";
                }
            }

            // Graph scenarios
            const scenarios = {
                social: {
                    name: "Social Network",
                    nodes: ["Alice", "Bob", "Carol", "David", "Eve", "Frank", "Grace", "Henry"],
                    edges: [
                        ["Alice", "Bob"],
                        ["Alice", "Carol"],
                        ["Bob", "Carol"], // Group 1
                        ["David", "Eve"],
                        ["David", "Frank"],
                        ["Eve", "Frank"], // Group 2
                        ["Grace", "Henry"], // Group 3
                        ["Carol", "David"],
                        ["Frank", "Grace"], // Bridges
                    ],
                    description: "Friend groups in a social network",
                },
                research: {
                    name: "Research Groups",
                    nodes: [
                        "AI_Lab",
                        "ML_Team",
                        "Data_Sci",
                        "NLP_Group",
                        "Vision_Lab",
                        "Robotics",
                        "Theory_Team",
                        "Systems",
                    ],
                    edges: [
                        ["AI_Lab", "ML_Team"],
                        ["AI_Lab", "NLP_Group"],
                        ["ML_Team", "Data_Sci"], // AI cluster
                        ["Vision_Lab", "Robotics"],
                        ["Vision_Lab", "Systems"], // Applied cluster
                        ["Theory_Team", "Systems"], // Theory cluster
                        ["ML_Team", "Vision_Lab"],
                        ["Data_Sci", "Theory_Team"], // Collaborations
                    ],
                    description: "Research group collaborations",
                },
                protein: {
                    name: "Protein Modules",
                    nodes: ["ATP1", "ATP2", "GLUC1", "GLUC2", "SIG1", "SIG2", "DNA1", "DNA2"],
                    edges: [
                        ["ATP1", "ATP2"],
                        ["ATP1", "GLUC1"],
                        ["ATP2", "GLUC2"], // Metabolic
                        ["SIG1", "SIG2"], // Signaling
                        ["DNA1", "DNA2"], // DNA repair
                        ["GLUC2", "SIG1"],
                        ["SIG2", "DNA1"], // Cross-pathway
                    ],
                    description: "Protein interaction modules",
                },
                technology: {
                    name: "Tech Companies",
                    nodes: ["Google", "Apple", "Microsoft", "Amazon", "Meta", "Netflix", "Spotify", "Tesla"],
                    edges: [
                        ["Google", "Apple"],
                        ["Google", "Microsoft"], // Big Tech
                        ["Amazon", "Microsoft"],
                        ["Amazon", "Netflix"], // Cloud/Services
                        ["Meta", "Netflix"],
                        ["Meta", "Spotify"], // Content/Social
                        ["Tesla", "Apple"],
                        ["Tesla", "Google"], // Innovation
                    ],
                    description: "Technology company ecosystems",
                },
            };

            let currentScenario = "social";
            let currentGraph = null;
            let isRunning = false;
            let currentStep = 0;
            let algorithmResult = null;
            let nodePositions = new Map();

            // Initialize graph visualization
            function initGraph() {
                const svg = document.getElementById("graph");
                svg.innerHTML = "";

                const scenario = scenarios[currentScenario];
                const nodes = scenario.nodes;
                const edges = scenario.edges;

                // Create graph in Map format for algorithm
                currentGraph = new Map();
                nodes.forEach((node) => {
                    currentGraph.set(node, new Map());
                });

                edges.forEach(([source, target]) => {
                    if (currentGraph.has(source) && currentGraph.has(target)) {
                        currentGraph.get(source).set(target, 1);
                        currentGraph.get(target).set(source, 1);
                    }
                });

                // Calculate positions for visualization
                const width = svg.clientWidth || 700;
                const height = svg.clientHeight || 400;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.35;

                nodePositions.clear();
                nodes.forEach((node, index) => {
                    const angle = (2 * Math.PI * index) / nodes.length;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    nodePositions.set(node, { x, y });
                });

                // Draw edges
                edges.forEach(([source, target]) => {
                    const sourcePos = nodePositions.get(source);
                    const targetPos = nodePositions.get(target);
                    if (sourcePos && targetPos) {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", sourcePos.x);
                        line.setAttribute("y1", sourcePos.y);
                        line.setAttribute("x2", targetPos.x);
                        line.setAttribute("y2", targetPos.y);
                        line.setAttribute("stroke", "#ccc");
                        line.setAttribute("stroke-width", "2");
                        svg.appendChild(line);
                    }
                });

                // Draw nodes
                nodes.forEach((node) => {
                    const pos = nodePositions.get(node);
                    if (pos) {
                        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        circle.setAttribute("cx", pos.x);
                        circle.setAttribute("cy", pos.y);
                        circle.setAttribute("r", "15");
                        circle.setAttribute("fill", "#e0e0e0");
                        circle.setAttribute("stroke", "#333");
                        circle.setAttribute("stroke-width", "2");
                        circle.setAttribute("id", `node-${node}`);
                        svg.appendChild(circle);

                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute("x", pos.x);
                        text.setAttribute("y", pos.y + 25);
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("font-size", "10px");
                        text.setAttribute("fill", "#333");
                        text.textContent = node;
                        svg.appendChild(text);
                    }
                });

                updateStepInfo(`Loaded ${scenario.name}: ${scenario.description}`);
            }

            // Load scenario
            window.loadScenario = function (scenarioKey) {
                currentScenario = scenarioKey;

                // Update button states
                document.querySelectorAll(".scenario-btn").forEach((btn) => {
                    btn.classList.remove("active");
                });
                event.target.classList.add("active");

                initGraph();
            };

            // Update parameter displays
            function updateParameterDisplays() {
                document.getElementById("clusters-value").textContent =
                    document.getElementById("clusters-slider").value;
                document.getElementById("learning-rate-value").textContent = parseFloat(
                    document.getElementById("learning-rate-slider").value,
                ).toFixed(3);
                document.getElementById("lambda-value").textContent = parseFloat(
                    document.getElementById("lambda-slider").value,
                ).toFixed(2);
                document.getElementById("seed-value").textContent = document.getElementById("seed-slider").value;
            }

            // Add event listeners for parameter updates
            document.getElementById("clusters-slider").addEventListener("input", updateParameterDisplays);
            document.getElementById("learning-rate-slider").addEventListener("input", updateParameterDisplays);
            document.getElementById("lambda-slider").addEventListener("input", updateParameterDisplays);
            document.getElementById("seed-slider").addEventListener("input", updateParameterDisplays);

            // Update step info
            function updateStepInfo(message) {
                document.getElementById("step-info").textContent = message;
            }

            // Update convergence info
            function updateConvergenceInfo(result) {
                document.getElementById("convergence-info").style.display = "grid";
                document.getElementById("iterations-value").textContent = result.iterations;
                document.getElementById("loss-value").textContent = result.loss.toFixed(3);
                document.getElementById("converged-value").textContent = result.converged ? "Yes" : "No";

                // Count unique clusters
                const uniqueClusters = new Set(result.clusters.values()).size;
                document.getElementById("final-clusters-value").textContent = uniqueClusters;
            }

            // Visualize embeddings
            function visualizeEmbeddings(embeddings) {
                const svg = document.getElementById("embedding-chart");
                svg.innerHTML = "";

                if (!embeddings || embeddings.size === 0) return;

                const width = svg.clientWidth || 700;
                const height = 200;

                // Simple 2D projection of embeddings (first two dimensions)
                const points = [];
                for (const [nodeId, embedding] of embeddings) {
                    if (embedding.length >= 2) {
                        points.push({
                            id: nodeId,
                            x: embedding[0],
                            y: embedding[1],
                        });
                    }
                }

                if (points.length === 0) return;

                // Normalize coordinates
                const xValues = points.map((p) => p.x);
                const yValues = points.map((p) => p.y);
                const minX = Math.min(...xValues);
                const maxX = Math.max(...xValues);
                const minY = Math.min(...yValues);
                const maxY = Math.max(...yValues);

                const margin = 20;
                points.forEach((point) => {
                    const normalizedX = margin + ((point.x - minX) / (maxX - minX)) * (width - 2 * margin);
                    const normalizedY = margin + ((point.y - minY) / (maxY - minY)) * (height - 2 * margin);

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", normalizedX);
                    circle.setAttribute("cy", normalizedY);
                    circle.setAttribute("r", "4");
                    circle.setAttribute("fill", "#2c5aa0");
                    circle.setAttribute("opacity", "0.7");
                    svg.appendChild(circle);

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", normalizedX);
                    text.setAttribute("y", normalizedY - 8);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("font-size", "8px");
                    text.setAttribute("fill", "#333");
                    text.textContent = point.id.substring(0, 3);
                    svg.appendChild(text);
                });
            }

            // Color nodes based on clusters
            function colorNodes(clusters) {
                const colors = ["#4CAF50", "#2196F3", "#9C27B0", "#FF5722", "#795548", "#607D8B"];

                clusters.forEach((clusterId, nodeId) => {
                    const nodeElement = document.getElementById(`node-${nodeId}`);
                    if (nodeElement) {
                        const color = colors[clusterId % colors.length];
                        nodeElement.setAttribute("fill", color);
                    }
                });
            }

            // Start algorithm animation
            window.startAlgorithm = function () {
                if (isRunning) return;

                isRunning = true;
                document.getElementById("start-btn").disabled = true;
                document.getElementById("step-btn").disabled = false;

                const config = {
                    numClusters: parseInt(document.getElementById("clusters-slider").value),
                    learningRate: parseFloat(document.getElementById("learning-rate-slider").value),
                    lambda: parseFloat(document.getElementById("lambda-slider").value),
                    seed: parseInt(document.getElementById("seed-slider").value),
                    maxIterations: 20, // Reduced for visualization
                };

                updateStepInfo("Running SynC algorithm...");

                // Highlight current step
                document.querySelectorAll(".algorithm-step").forEach((step) => {
                    step.classList.remove("active");
                });
                document.querySelectorAll(".algorithm-step")[0].classList.add("active");

                setTimeout(() => {
                    try {
                        algorithmResult = syncClustering(currentGraph, config);
                        console.log("SynC Result:", algorithmResult);

                        animateResult();
                    } catch (error) {
                        console.error("Error running SynC:", error);
                        updateStepInfo("Error running algorithm: " + error.message);
                        resetVisualization();
                    }
                }, 500);
            };

            // Animate algorithm result
            function animateResult() {
                if (!algorithmResult) return;

                updateStepInfo("Visualizing SynC clustering results...");
                updateConvergenceInfo(algorithmResult);

                // Animate node coloring
                setTimeout(() => {
                    colorNodes(algorithmResult.clusters);
                    visualizeEmbeddings(algorithmResult.embeddings);

                    const uniqueClusters = new Set(algorithmResult.clusters.values()).size;
                    updateStepInfo(
                        `SynC completed: Found ${uniqueClusters} clusters in ${algorithmResult.iterations} iterations (loss: ${algorithmResult.loss.toFixed(3)})`,
                    );

                    document.getElementById("start-btn").disabled = false;
                    document.getElementById("step-btn").disabled = true;
                    isRunning = false;
                }, 1500);
            }

            // Step through algorithm (simplified)
            window.stepAlgorithm = function () {
                if (!isRunning) return;

                currentStep = (currentStep + 1) % 5;

                // Highlight current step
                document.querySelectorAll(".algorithm-step").forEach((step, index) => {
                    step.classList.toggle("active", index === currentStep);
                });

                const stepMessages = [
                    "Initializing node embeddings and cluster centers...",
                    "Assigning nodes to nearest cluster centers...",
                    "Updating embeddings to preserve graph structure...",
                    "Recalculating cluster centers...",
                    "Checking convergence criteria...",
                ];

                updateStepInfo(stepMessages[currentStep]);
            };

            // Reset visualization
            window.resetVisualization = function () {
                isRunning = false;
                currentStep = 0;
                algorithmResult = null;

                document.getElementById("start-btn").disabled = false;
                document.getElementById("step-btn").disabled = true;
                document.getElementById("convergence-info").style.display = "none";

                document.querySelectorAll(".algorithm-step").forEach((step) => {
                    step.classList.remove("active");
                });

                // Reset node colors
                const scenario = scenarios[currentScenario];
                scenario.nodes.forEach((node) => {
                    const nodeElement = document.getElementById(`node-${node}`);
                    if (nodeElement) {
                        nodeElement.setAttribute("fill", "#e0e0e0");
                    }
                });

                // Clear embedding visualization
                document.getElementById("embedding-chart").innerHTML = "";

                updateStepInfo('Click "Start SynC" to see how synergistic deep clustering works');
            };

            // Code toggle functionality
            window.toggleCode = function () {
                const content = document.getElementById("code-content");
                const toggle = document.getElementById("code-toggle");

                if (content.style.display === "none") {
                    content.style.display = "block";
                    toggle.textContent = "Hide Code ‚ñ≤";
                } else {
                    content.style.display = "none";
                    toggle.textContent = "Show Code ‚ñº";
                }
            };

            document.getElementById("code-toggle").addEventListener("click", toggleCode);

            // Initialize on load
            window.onload = function () {
                updateParameterDisplays();
                initGraph();
                loadCodeExample();

                // Run comprehensive tests
                console.log("üß† Running SynC (Synergistic Deep Graph Clustering) comprehensive tests...");
                runAllSynCTests();
            };
        </script>
    </body>
</html>
