/**
 * THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE.
 * INSTEAD EDIT the implementation plan in design/mesh-based-patterned-lines.md
 *
 * PatternedLineMesh - Manages pattern meshes for a single edge line
 *
 * Architecture:
 * - Individual meshes in world space (no parent/child hierarchy)
 * - Uses FilledArrowRenderer shader for billboarding
 * - Adaptive mesh density (add/remove meshes as line length changes)
 * - Proven 35x faster than thin instances for position updates
 *
 * @remarks
 * This class implements Phases 1-4 of mesh-based-patterned-lines.md
 * - Phase 1: Basic infrastructure with discrete patterns
 * - Phase 2: Adaptive mesh density with hysteresis
 * - Phase 3: Alternating patterns (dash-dot) support
 * - Phase 4: Connected patterns (sinewave, zigzag) positioning
 */

import {Mesh, Scene, ShaderMaterial, Vector3} from "@babylonjs/core";

import {FilledArrowRenderer} from "./FilledArrowRenderer";
import {
    PATTERN_DEFINITIONS,
    type PatternDefinition,
    PatternedLineRenderer,
    type PatternType,
} from "./PatternedLineRenderer";

export class PatternedLineMesh {
    meshes: Mesh[] = []; // Individual pattern meshes in world space
    pattern: PatternType;
    lineDirection = new Vector3(1, 0, 0);
    private lastLength = 0;
    private scene: Scene;
    private width: number;
    private color: string;
    private opacity: number;
    private static readonly SEGMENT_LENGTH = 0.75; // Fixed segment length for all edges (for instancing)

    // PHASE 5: Edge compatibility properties (mimic AbstractMesh interface)
    // These aren't used by PatternedLineMesh but are set by Edge.ts for consistency
    isPickable = false;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    metadata: any = {};

    constructor(
        pattern: PatternType,
        start: Vector3,
        end: Vector3,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
    ) {
        this.pattern = pattern;
        this.scene = scene;
        this.width = width;
        this.color = color;
        this.opacity = opacity;

        this.createInitialMeshes(start, end);
    }

    /**
     * Update pattern mesh positions when line endpoints change
     * Called every frame by Edge.update() during physics simulation
     */
    update(start: Vector3, end: Vector3): void {
        const newLength = Vector3.Distance(start, end);
        this.lineDirection = end.subtract(start).normalize();

        // Adaptive density: adjust mesh count if needed
        if (this.needsMeshCountAdjustment(newLength)) {
            this.adjustMeshCount(newLength);
        }

        // Update positions (world space)
        const positions = this.calculatePositions(start, end);
        for (let i = 0; i < this.meshes.length; i++) {
            this.meshes[i].position = positions[i];

            // CRITICAL: Update lineDirection uniform for billboarding shader
            // This makes pattern meshes face the camera like arrowheads do
            FilledArrowRenderer.setLineDirection(this.meshes[i], this.lineDirection);
        }

        // For connected patterns, clip last segment to fit exactly
        const patternDef = PATTERN_DEFINITIONS[this.pattern];
        if (patternDef.connected && this.meshes.length > 0) {
            this.clipLastSegment(newLength);
        }

        this.lastLength = newLength;
    }

    /**
     * Clip the last segment to fit exactly to line end
     * Uses shader-based clipping instead of mesh scaling
     * All segments use identical 0.75 geometry (for instancing)
     */
    private clipLastSegment(lineLength: number): void {
        const lastIndex = this.meshes.length - 1;
        const lastMesh = this.meshes[lastIndex];

        // Calculate how much of the last segment should be visible
        const fullSegmentsLength = lastIndex * PatternedLineMesh.SEGMENT_LENGTH;
        const remainingLength = Math.max(0, lineLength - fullSegmentsLength);

        // Set clip uniform on the last segment's material
        const material = lastMesh.material as ShaderMaterial;
        // If remainder is nearly full segment (>0.74), don't clip
        if (remainingLength > 0.74) {
            material.setFloat("clipEndX", -1.0); // Disable clipping
        } else {
            material.setFloat("clipEndX", remainingLength);
        }

        // Reset scaling (no longer needed)
        lastMesh.scaling.set(1, 1, 1);
    }

    /**
     * Dispose all pattern meshes
     */
    dispose(): void {
        for (const mesh of this.meshes) {
            mesh.dispose();
        }
        this.meshes = [];
    }

    /**
     * Create initial pattern meshes based on line length
     * Phase 3: Updated to handle alternating patterns
     */
    private createInitialMeshes(start: Vector3, end: Vector3): void {
        const length = Vector3.Distance(start, end);
        this.lastLength = length;
        this.lineDirection = end.subtract(start).normalize();

        const patternDef = PATTERN_DEFINITIONS[this.pattern];
        const meshCount = this.calculateOptimalMeshCount(length, patternDef);

        // Phase 3: Create meshes with alternating shapes for multi-shape patterns
        for (let i = 0; i < meshCount; i++) {
            const mesh = this.createPatternMesh(i);
            this.meshes.push(mesh);
        }

        // Set initial positions and lineDirection
        const positions = this.calculatePositions(start, end);
        for (let i = 0; i < this.meshes.length; i++) {
            this.meshes[i].position = positions[i];

            // Set lineDirection uniform for billboarding
            FilledArrowRenderer.setLineDirection(this.meshes[i], this.lineDirection);
        }
    }

    /**
     * Check if mesh count needs adjustment based on line length change
     * Uses hysteresis (±1 mesh) to prevent thrashing
     */
    private needsMeshCountAdjustment(newLength: number): boolean {
        const patternDef = PATTERN_DEFINITIONS[this.pattern];
        const currentCount = this.meshes.length;
        const optimalCount = this.calculateOptimalMeshCount(newLength, patternDef);

        return Math.abs(currentCount - optimalCount) > 1; // Hysteresis: ±1 mesh
    }

    /**
     * Add or remove meshes to match optimal count
     * Phase 3: Updated to handle alternating patterns when adding meshes
     */
    private adjustMeshCount(newLength: number): void {
        const patternDef = PATTERN_DEFINITIONS[this.pattern];
        const optimalCount = this.calculateOptimalMeshCount(newLength, patternDef);
        const currentCount = this.meshes.length;

        if (optimalCount > currentCount) {
            // Phase 3: Add meshes with correct alternating shapes
            for (let i = 0; i < optimalCount - currentCount; i++) {
                // Use current count + i to get the next mesh index in sequence
                const meshIndex = currentCount + i;
                const mesh = this.createPatternMesh(meshIndex);
                this.meshes.push(mesh);
            }
        } else if (optimalCount < currentCount) {
            // Remove meshes
            const toRemove = currentCount - optimalCount;
            for (let i = 0; i < toRemove; i++) {
                const mesh = this.meshes.pop();
                mesh?.dispose();
            }
        }
    }

    /**
     * Calculate mesh positions along the line
     * Supports both discrete patterns (with spacing) and connected patterns (seamless)
     */
    private calculatePositions(start: Vector3, end: Vector3): Vector3[] {
        const patternDef = PATTERN_DEFINITIONS[this.pattern];

        if (patternDef.connected) {
            return this.calculateConnectedPositions(start, end, patternDef);
        }

        return this.calculateDiscretePositions(start, end, patternDef);
    }

    /**
     * Calculate positions for discrete patterns (dot, star, dash, diamond, dash-dot)
     * Algorithm: first/last touch boundaries, interior evenly distributed with calculated spacing
     *
     * IMPORTANT: start and end are ALREADY adjusted by Edge.transformArrowCap():
     *  - start = ray intersection with source node surface
     *  - end = destination surface minus arrow length
     * DO NOT subtract nodeRadius or arrowLength again!
     */
    private calculateDiscretePositions(
        start: Vector3,
        end: Vector3,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _patternDef: PatternDefinition,
    ): Vector3[] {
        const direction = end.subtract(start).normalize();
        const totalLength = Vector3.Distance(start, end);

        const meshWidth = this.getRenderedMeshSize();
        const meshRadius = meshWidth / 2;

        // start and end are ALREADY adjusted for node surface and arrow
        // First mesh left edge should be at distance 0 from start
        // Last mesh right edge should be at distance totalLength from start
        const lineStart = 0;
        const lineEnd = totalLength;

        const meshCount = this.meshes.length;

        // Special case: 2 meshes (just first and last)
        if (meshCount === 2) {
            const firstPos = lineStart + meshRadius;
            const lastPos = lineEnd - meshRadius;
            return [
                start.add(direction.scale(firstPos)), // First mesh center
                start.add(direction.scale(lastPos)), // Last mesh center
            ];
        }

        // General case: first + interior + last meshes
        const numInterior = meshCount - 2;
        const numGaps = numInterior + 1;

        // Dynamic line length (between first and last mesh edges)
        const firstMeshRightEdge = lineStart + meshWidth;
        const lastMeshLeftEdge = lineEnd - meshWidth;
        const dynamicLength = lastMeshLeftEdge - firstMeshRightEdge;

        // Calculate actual spacing
        // IMPORTANT: Spacing should be based on visual HEIGHT (this.width), not parallel length (meshWidth)
        // This ensures gaps scale with the perpendicular dimension, not the aspect ratio
        const minSpacing = this.width * 0.5;
        const remainder = dynamicLength - (numInterior * meshWidth) - (numGaps * minSpacing);
        const actualSpacing = minSpacing + (remainder / numGaps);

        // Build positions
        const positions: Vector3[] = [];

        // First mesh
        const firstMeshPos = lineStart + meshRadius;
        positions.push(start.add(direction.scale(firstMeshPos)));

        // Interior meshes
        let currentPos = firstMeshRightEdge + actualSpacing + meshRadius;
        for (let i = 0; i < numInterior; i++) {
            positions.push(start.add(direction.scale(currentPos)));
            currentPos += meshWidth + actualSpacing;
        }

        // Last mesh
        const lastMeshPos = lineEnd - meshRadius;
        positions.push(start.add(direction.scale(lastMeshPos)));

        return positions;
    }

    /**
     * Calculate positions for connected patterns (sinewave, zigzag)
     * Phase 4: Seamless connection - meshes positioned at fixed intervals
     *
     * All segments use FIXED 0.75 geometry (for instancing).
     * Last segment is scaled in X-direction to fit exactly (see scaleLastSegment).
     */
    private calculateConnectedPositions(
        start: Vector3,
        end: Vector3,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _patternDef: PatternDefinition,
    ): Vector3[] {
        const direction = end.subtract(start).normalize();

        const meshCount = this.meshes.length;
        const positions: Vector3[] = [];

        // Position segments at fixed 0.75 intervals (same geometry for all)
        for (let i = 0; i < meshCount; i++) {
            const distance = i * PatternedLineMesh.SEGMENT_LENGTH;
            positions.push(start.add(direction.scale(distance)));
        }

        return positions;
    }

    /**
     * Get the actual rendered size of pattern meshes (parallel dimension along the line)
     *
     * PatternedLineRenderer scales meshes so their perpendicular dimension matches line width:
     *   shaderSize = width / geometryPerpendicularDiameter
     *
     * This method calculates the PARALLEL dimension (length along the line) after scaling.
     *
     * For circles/stars:
     *   - Geometry has diameter 2.0 in all directions
     *   - Rendered size = 2.0 × (width / 2.0) = width
     *
     * For boxes with aspectRatio:
     *   - Geometry has perpendicular width = 1.0/aspectRatio, parallel length = 1.0
     *   - Rendered parallel = 1.0 × (width / (1.0/aspectRatio)) = width × aspectRatio
     *
     * For diamonds/waves/zigzags:
     *   - Geometry has diameter 1.0 in both directions
     *   - Rendered size = 1.0 × (width / 1.0) = width
     */
    private getRenderedMeshSize(): number {
        const patternDef = PATTERN_DEFINITIONS[this.pattern];

        // For alternating patterns, we need to handle both shapes
        // For now, use the first shape as representative (this is for spacing calculations)
        const shapeDef = patternDef.shapes[0];
        const aspectRatio = shapeDef.aspectRatio ?? 1.0;

        switch (shapeDef.type) {
            case "circle":
            case "star":
                // Circular shapes: rendered diameter = width
                return this.width;
            case "box":
                // Box: rendered parallel length = width × aspectRatio
                return this.width * aspectRatio;
            case "diamond":
            case "sinewave-segment":
            case "zigzag-segment":
                // These have 1:1 aspect ratio: rendered size = width
                return this.width;
            default:
                return this.width;
        }
    }

    /**
     * Calculate optimal number of meshes for current line length
     * Algorithm: first/last meshes touch boundaries, interior meshes evenly distributed
     */
    private calculateOptimalMeshCount(
        lineLength: number,
        patternDef: PatternDefinition,
    ): number {
        if (patternDef.connected) {
            // For connected patterns, use fixed 0.75 segment length
            // Last segment will be scaled to fit remainder (see scaleLastSegment)
            const segments = Math.ceil(lineLength / PatternedLineMesh.SEGMENT_LENGTH);
            return Math.max(1, segments);
        }

        const meshWidth = this.getRenderedMeshSize(); // W

        // lineLength is ALREADY adjusted for node surface and arrow
        // (done by Edge.transformArrowCap())
        const adjustedLength = lineLength;

        // Dynamic line length (space between first and last mesh)
        const dynamicLength = adjustedLength - (2 * meshWidth);

        // Handle edge case: line too short for interior meshes
        if (dynamicLength < 0) {
            return 2; // Just first and last mesh
        }

        // Spacing constraints
        // IMPORTANT: Spacing should be based on visual HEIGHT (this.width), not parallel length (meshWidth)
        const minSpacing = this.width * 0.5;

        // Calculate number of interior meshes
        // Formula: K interior meshes create K+1 gaps
        // K × W + (K + 1) × min_spacing ≤ dynamic_length
        // Solving: K ≤ (dynamic_length - min_spacing) / (W + min_spacing)
        const numInterior = Math.floor(
            (dynamicLength - minSpacing) / (meshWidth + minSpacing),
        );

        // Total meshes = first + last + interior
        const totalMeshes = 2 + Math.max(0, numInterior);

        return totalMeshes;
    }

    /**
     * Create a single pattern mesh
     * Phase 3: Updated to handle alternating patterns via mesh index
     * @param meshIndex - Index of the mesh in the sequence (for alternating patterns)
     */
    private createPatternMesh(meshIndex: number): Mesh {
        const patternDef = PATTERN_DEFINITIONS[this.pattern];

        // Phase 3: For multi-shape patterns, determine which shape to use based on index
        let shapeType: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment" | undefined;

        if (patternDef.shapes.length > 1) {
            // Alternating pattern: use modulo to cycle through shapes
            const shapeIndex = meshIndex % patternDef.shapes.length;
            shapeType = patternDef.shapes[shapeIndex].type;
        }

        // All segments use FIXED 0.75 geometry (for instancing)
        // No custom segment length passed - uses default 0.75
        const mesh = PatternedLineRenderer.createPatternMesh(
            this.pattern,
            this.width,
            this.color,
            this.opacity,
            this.scene,
            shapeType,
        );

        // Initialize as non-clipped (will be updated in clipLastSegment if needed)
        if (patternDef.connected) {
            const material = mesh.material as ShaderMaterial;
            material.setFloat("clipEndX", -1.0); // -1.0 = no clipping
        }

        return mesh;
    }
}
