/**
 * THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE.
 * INSTEAD EDIT the implementation plan in design/mesh-based-patterned-lines.md
 *
 * PatternedLineRenderer - Creates mesh-based patterns for line visualization
 *
 * Architecture:
 * - Static utility class for creating pattern geometries
 * - ALL geometries MUST use XZ plane (Y=0) for proper billboarding
 * - Uses FilledArrowRenderer shader for tangent billboarding
 * - Batched camera updates for performance
 * @remarks
 * This implements Phases 1-4 of mesh-based-patterned-lines.md
 * - Phase 1: Discrete patterns (dot, star, dash, diamond) with billboarding
 * - Phase 2: Adaptive density (add/remove meshes based on line length)
 * - Phase 3: Alternating patterns (dash-dot)
 * - Phase 4: Connected patterns (sinewave, zigzag) with seamless connection
 */

import { Mesh, Scene, ShaderMaterial, Vector3, VertexData } from "@babylonjs/core";

import { FilledArrowRenderer } from "./FilledArrowRenderer";
import { MaterialHelper } from "./MaterialHelper";
import { PatternedLineMesh } from "./PatternedLineMesh";

// ==========================================
// PATTERN TYPE DEFINITIONS
// ==========================================

export type PatternType = "dot" | "star" | "box" | "dash" | "diamond" | "dash-dot" | "sinewave" | "zigzag";

interface ShapeDefinition {
    type: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment";
    size?: number; // Base size multiplier (default 1.0)
    aspectRatio?: number; // For elongated shapes (default 1.0)
    points?: number; // For star (default 5)
    angle?: number; // For zigzag (default 60)
    periods?: number; // For sinewave (default 0.5)
}

interface SpacingConfig {
    min: number; // Minimum spacing (below this, remove meshes)
    ideal: number; // Target spacing
    max: number; // Maximum spacing (above this, add meshes)
}

export interface PatternDefinition {
    shapes: ShapeDefinition[];
    spacing: SpacingConfig;
    connected: boolean;
}

// ==========================================
// PATTERN REGISTRY
// ==========================================

export const PATTERN_DEFINITIONS: Record<PatternType, PatternDefinition> = {
    dot: {
        shapes: [{ type: "circle", size: 1.0 }],
        spacing: { min: 0.2, ideal: 0.5, max: 1.0 },
        connected: false,
    },
    star: {
        shapes: [{ type: "star", size: 1.0, points: 5 }],
        spacing: { min: 0.3, ideal: 0.6, max: 1.2 },
        connected: false,
    },
    box: {
        shapes: [{ type: "box", size: 1.0, aspectRatio: 1.0 }],
        spacing: { min: 0.2, ideal: 0.5, max: 1.0 },
        connected: false,
    },
    dash: {
        shapes: [{ type: "box", size: 1.0, aspectRatio: 3.0 }],
        spacing: { min: 0.2, ideal: 0.4, max: 0.8 },
        connected: false,
    },
    diamond: {
        shapes: [{ type: "diamond", size: 1.0 }],
        spacing: { min: 0.2, ideal: 0.5, max: 1.0 },
        connected: false,
    },
    "dash-dot": {
        shapes: [
            { type: "box", size: 1.0, aspectRatio: 3.0 },
            { type: "circle", size: 0.6 },
        ],
        spacing: { min: 0.15, ideal: 0.3, max: 0.6 },
        connected: false,
    },
    sinewave: {
        shapes: [{ type: "sinewave-segment", size: 1.0, periods: 0.5 }],
        spacing: { min: 0, ideal: 0, max: 0 },
        connected: true,
    },
    zigzag: {
        shapes: [{ type: "zigzag-segment", size: 1.0, angle: 90 }],
        spacing: { min: 0, ideal: 0, max: 0 },
        connected: true, // Connected pattern - no gaps between segments
    },
};

// ==========================================
// RENDERER CLASS
// ==========================================

/**
 * Static utility class for creating mesh-based pattern geometries for line visualization
 */
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
export class PatternedLineRenderer {
    private static activeMaterials = new Set<ShaderMaterial>();
    private static cameraCallbackRegistered = false;

    /**
     * Create a PatternedLineMesh instance
     * Note: start/end are already adjusted by Edge.transformArrowCap() for node surfaces and arrows
     * @param pattern - The pattern type to render
     * @param start - Starting point of the line (already adjusted)
     * @param end - Ending point of the line (already adjusted)
     * @param width - Line width
     * @param color - Line color
     * @param opacity - Line opacity (0-1)
     * @param scene - Babylon.js scene
     * @param is2DMode - Optional flag to apply 2D materials instead of 3D shader (default false)
     * @returns A PatternedLineMesh instance
     */
    static create(
        pattern: PatternType,
        start: Vector3,
        end: Vector3,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
        is2DMode?: boolean,
    ): PatternedLineMesh {
        // Register camera callback for batched shader updates
        this.registerCameraCallback(scene);

        // For connected patterns (zigzag, sinewave), use zero-spacing discrete meshes
        // This is more efficient than creating one large mesh
        const patternDef = PATTERN_DEFINITIONS[pattern];
        if (patternDef.connected) {
            return this.createContinuousMesh(pattern, start, end, width, color, opacity, scene, is2DMode);
        }

        return new PatternedLineMesh(pattern, start, end, width, color, opacity, scene, is2DMode);
    }

    /**
     * Create connected pattern using repeating segment meshes with ZERO spacing
     * Used for patterns like zigzag that need seamless tiling
     * Uses same efficient approach as discrete patterns (dot/star/etc) but with spacing=0
     * @param pattern - The pattern type to render
     * @param start - Starting point of the line
     * @param end - Ending point of the line
     * @param width - Line width
     * @param color - Line color
     * @param opacity - Line opacity (0-1)
     * @param scene - Babylon.js scene
     * @param is2DMode - Whether to use 2D mode rendering
     * @returns A PatternedLineMesh instance
     */
    static createContinuousMesh(
        pattern: PatternType,
        start: Vector3,
        end: Vector3,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
        is2DMode?: boolean,
    ): PatternedLineMesh {
        // Use PatternedLineMesh approach (multiple small meshes) with zero spacing
        // This is more efficient than creating one large mesh with many vertices
        return new PatternedLineMesh(pattern, start, end, width, color, opacity, scene, is2DMode);
    }

    /**
     * Create a single pattern mesh with appropriate geometry and shader
     * Phase 3: Now accepts shapeType parameter for alternating patterns and is2DMode flag
     * @param pattern - The pattern type to render
     * @param width - Line width
     * @param color - Line color
     * @param opacity - Line opacity (0-1)
     * @param scene - Babylon.js scene
     * @param shapeType - Optional specific shape type for alternating patterns
     * @param segmentLength - Optional segment length for connected patterns (for exact fit per edge)
     * @param is2DMode - Optional flag to apply 2D materials instead of 3D shader (default false)
     * @returns The created pattern mesh
     */
    static createPatternMesh(
        pattern: PatternType,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
        shapeType?: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
        segmentLength?: number,
        is2DMode?: boolean,
    ): Mesh {
        const patternDef = PATTERN_DEFINITIONS[pattern];

        // For connected patterns (zigzag, sinewave), create pre-scaled geometry
        // Segment length can be adjusted per edge for exact fit
        if (patternDef.connected) {
            const geometry = this.createConnectedSegmentGeometry(pattern, width, segmentLength);
            const meshName = `pattern-${pattern}`;
            const mesh = new Mesh(meshName, scene);
            geometry.applyToMesh(mesh);

            // Apply material based on mode
            if (is2DMode) {
                MaterialHelper.apply2DMaterial(mesh, color, opacity, scene);

                // Compute normals from geometry for proper lighting and backface culling
                // This is more efficient than computing at creation time since we only
                // compute once for 2D mode rather than for all modes
                const positions = mesh.getVerticesData("position");
                const indices = mesh.getIndices();
                if (positions && indices && !mesh.getVerticesData("normal")) {
                    const normals: number[] = [];
                    VertexData.ComputeNormals(positions, indices, normals);
                    mesh.setVerticesData("normal", normals);
                }
            } else {
                // Use shader size=1.0 since geometry is already at correct scale
                FilledArrowRenderer.applyShader(mesh, { size: 1.0, color, opacity }, scene);

                const material = mesh.material as ShaderMaterial;
                this.activeMaterials.add(material);
            }

            return mesh;
        }

        // For discrete patterns, use standard scaling approach
        // Get geometry for pattern type
        // Phase 3: Use shapeType if provided, otherwise derive from pattern
        const geometry = shapeType ? this.getGeometryForShapeType(shapeType) : this.getGeometryForPattern(pattern);

        // Create mesh from geometry
        const meshName = shapeType ? `pattern-${pattern}-${shapeType}` : `pattern-${pattern}`;
        const mesh = new Mesh(meshName, scene);
        geometry.applyToMesh(mesh);

        // Apply material based on mode
        if (is2DMode) {
            // 2D mode: Use StandardMaterial with flat shading
            MaterialHelper.apply2DMaterial(mesh, color, opacity, scene);

            // Scale mesh to desired size (same calculation as shader does in 3D)
            const geometryDiameter = this.getGeometryDiameter(pattern, shapeType);
            const scale = width / geometryDiameter;
            mesh.scaling.set(scale, scale, scale);

            // Compute normals from geometry for proper lighting and backface culling
            // This is more efficient than computing at creation time since we only
            // compute once for 2D mode rather than for all modes
            const positions = mesh.getVerticesData("position");
            const indices = mesh.getIndices();
            if (positions && indices && !mesh.getVerticesData("normal")) {
                const normals: number[] = [];
                VertexData.ComputeNormals(positions, indices, normals);
                mesh.setVerticesData("normal", normals);
            }
        } else {
            // 3D mode: Apply FilledArrowRenderer shader
            // Calculate shader size to achieve desired visual width (perpendicular to line)
            // For geometries with perpendicular diameter D, shader size = desiredWidth / D
            const geometryDiameter = this.getGeometryDiameter(pattern, shapeType);
            const size = width / geometryDiameter;

            FilledArrowRenderer.applyShader(mesh, { size, color, opacity }, scene);

            // Track material for batched updates
            const material = mesh.material as ShaderMaterial;
            this.activeMaterials.add(material);
        }

        return mesh;
    }

    /**
     * Create geometry for connected patterns (zigzag, sinewave) pre-scaled to width
     * Segment length can be adjusted per edge for exact fit
     * @param pattern - Pattern type (zigzag or sinewave)
     * @param width - Desired visual width (scales amplitude/thickness, not X-length)
     * @param segmentLength - X-length of one pattern period (defaults to 0.75)
     * @returns VertexData with specified segment length and amplitude/thickness proportional to width
     */
    private static createConnectedSegmentGeometry(
        pattern: PatternType,
        width: number,
        segmentLength = 0.75,
    ): VertexData {
        const amplitude = width / 2; // Amplitude proportional to width
        const thickness = width * 0.1; // Thickness proportional to width

        switch (pattern) {
            case "zigzag":
                return this.createZigzagSegmentGeometry(segmentLength, amplitude, thickness);
            case "sinewave":
                // Use 1.0 period per segment for seamless tiling
                return this.createSinewaveSegmentGeometry(segmentLength, amplitude, 1.0, thickness);
            default:
                throw new Error(`Unknown connected pattern: ${pattern}`);
        }
    }

    /**
     * Get geometry for a pattern type
     * @param pattern - The pattern type
     * @returns VertexData for the pattern
     */
    private static getGeometryForPattern(pattern: PatternType): VertexData {
        switch (pattern) {
            case "dot":
                return this.createCircleGeometry();
            case "star":
                return this.createStarGeometry();
            case "box":
                return this.createBoxGeometry(1.0); // aspect ratio 1:1 (square)
            case "dash":
                return this.createBoxGeometry(3.0); // aspect ratio 3:1
            case "diamond":
                return this.createDiamondGeometry();
            case "dash-dot":
                // Phase 3: For dash-dot, default to box (first shape)
                // Actual alternation is handled via shapeType parameter in createPatternMesh
                return this.createBoxGeometry(3.0);
            case "sinewave":
                return this.createSinewaveSegmentGeometry();
            case "zigzag":
                return this.createZigzagSegmentGeometry();
            default:
                throw new Error(`Unsupported pattern type: ${pattern as string}`);
        }
    }

    /**
     * Get geometry for a specific shape type
     * Phase 3: Enables alternating patterns (e.g., dash-dot)
     * @param shapeType - The shape type
     * @returns VertexData for the shape
     */
    private static getGeometryForShapeType(
        shapeType: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): VertexData {
        switch (shapeType) {
            case "circle":
                return this.createCircleGeometry();
            case "star":
                return this.createStarGeometry();
            case "box":
                return this.createBoxGeometry(3.0);
            case "diamond":
                return this.createDiamondGeometry();
            case "sinewave-segment":
                return this.createSinewaveSegmentGeometry();
            case "zigzag-segment":
                return this.createZigzagSegmentGeometry();
            default:
                throw new Error(`Unsupported shape type: ${shapeType as string}`);
        }
    }

    // ==========================================
    // GEOMETRY GENERATORS
    // CRITICAL: ALL MUST USE XZ PLANE (Y=0)!
    // ==========================================

    /**
     * Create circle geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     * @param segments - Number of segments in the circle
     * @returns VertexData for a circle
     */
    private static createCircleGeometry(segments = 32): VertexData {
        const positions: number[] = [0, 0, 0]; // Center
        const indices: number[] = [];

        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            // XZ plane (Y=0)
            positions.push(
                Math.cos(angle), // X
                0, // Y = 0
                Math.sin(angle), // Z
            );

            if (i < segments) {
                indices.push(0, i + 1, i + 2);
            }
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create star geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     * @param points - Number of star points
     * @param innerRadius - Inner radius of the star
     * @param outerRadius - Outer radius of the star
     * @returns VertexData for a star
     */
    private static createStarGeometry(points = 5, innerRadius = 0.4, outerRadius = 1.0): VertexData {
        const positions: number[] = [0, 0, 0]; // Center
        const indices: number[] = [];
        const totalPoints = points * 2;

        for (let i = 0; i <= totalPoints; i++) {
            const angle = (i / totalPoints) * Math.PI * 2;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            // XZ plane (Y=0)
            positions.push(
                Math.cos(angle) * radius, // X
                0, // Y = 0
                Math.sin(angle) * radius, // Z
            );

            if (i < totalPoints) {
                indices.push(0, i + 1, i + 2);
            }
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create box geometry in XZ plane (Y=0)
     * Elongated rectangle for dashes
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     * @param aspectRatio - Aspect ratio (length/width)
     * @returns VertexData for a box
     */
    private static createBoxGeometry(aspectRatio = 1.0): VertexData {
        const length = 1.0;
        const width = length / aspectRatio;
        const halfLength = length / 2;
        const halfWidth = width / 2;

        // XZ plane (Y=0), centered at origin, extends along +/- X
        const positions = [
            -halfLength,
            0,
            halfWidth, // Top-left
            halfLength,
            0,
            halfWidth, // Top-right
            halfLength,
            0,
            -halfWidth, // Bottom-right
            -halfLength,
            0,
            -halfWidth, // Bottom-left
        ];

        const indices = [
            0,
            1,
            2, // First triangle
            0,
            2,
            3, // Second triangle
        ];

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create diamond geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     * @returns VertexData for a diamond
     */
    private static createDiamondGeometry(): VertexData {
        const length = 1.0;
        const width = 0.8;

        // XZ plane (Y=0), centered at origin like other shapes
        // Diamond extends from -length/2 to +length/2 along X axis
        const positions = [
            length / 2,
            0,
            0, // Front tip (right)
            0,
            0,
            width / 2, // Top (center-top)
            -length / 2,
            0,
            0, // Back tip (left)
            0,
            0,
            -width / 2, // Bottom (center-bottom)
        ];

        const indices = [
            0,
            1,
            2, // Top half
            0,
            2,
            3, // Bottom half
        ];

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create sinewave segment geometry in XZ plane (Y=0)
     * Creates a quad strip following a sine wave for seamless tiling
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     *
     * IMPORTANT: For seamless tiling, each segment must contain exactly 1 complete wave period.
     * This ensures that when segments are placed end-to-end at 0.75 unit intervals,
     * the wave pattern continues smoothly without discontinuities.
     * @param segmentLength - Length of one segment (default 1.0, typically 0.75 for tiling)
     * @param amplitude - Wave amplitude (default 0.3)
     * @param periods - Number of complete sine wave periods per segment (should be 1.0 for seamless tiling)
     * @param thickness - Line thickness (quad strip width), default proportional to amplitude
     * @returns VertexData with positions and indices for quad strip
     */
    private static createSinewaveSegmentGeometry(
        segmentLength = 1.0,
        amplitude = 0.3,
        periods = 1.0, // Changed from 0.5 to 1.0 for proper tiling!
        thickness = amplitude * 0.2,
    ): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];
        const segments = 20; // Smooth curve

        // Generate sine wave vertices in XZ plane (Y=0)
        // For seamless tiling: z = amplitude * sin(2π * x / wavelength)
        // where wavelength = segmentLength / periods
        const wavelength = segmentLength / periods;

        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = t * segmentLength;
            // Use absolute X position for phase to ensure continuity between segments
            const z = amplitude * Math.sin((2 * Math.PI * x) / wavelength);

            // Calculate the tangent (derivative) to apply thickness perpendicular to curve
            // dz/dx = amplitude * cos(2π * x / wavelength) * (2π / wavelength)
            const derivative = amplitude * Math.cos((2 * Math.PI * x) / wavelength) * ((2 * Math.PI) / wavelength);

            // Tangent vector in XZ plane: (1, dz/dx)
            // Normal (perpendicular) vector: (-dz/dx, 1)
            // Normalize to get unit normal
            const normalLength = Math.sqrt(derivative * derivative + 1);
            const nx = -derivative / normalLength;
            const nz = 1 / normalLength;

            // Apply thickness along the normal direction (perpendicular to curve)
            positions.push(x + nx * thickness, 0, z + nz * thickness); // Bottom
            positions.push(x - nx * thickness, 0, z - nz * thickness); // Top
        }

        // Create triangle indices for quad strip
        for (let i = 0; i < segments; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create continuous zigzag geometry for the full line length (ZERO spacing)
     * Generates a seamless zigzag pattern along the entire X axis
     * @param lineLength - Total length of the line
     * @returns VertexData with positions and indices for continuous quad strip
     */
    static createContinuousZigzag(lineLength: number): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];

        // Pattern configuration
        const segmentLength = 1.275; // Length of one complete /\/\ period (15% shorter than 1.5)
        const thickness = 0.15; // Line thickness perpendicular to the zigzag

        // Calculate diagonal segment length and amplitude
        // For 90-degree angles at corners, each diagonal must be at 45 degrees
        // This means rise = run, so amplitude = diagonalLength
        const segmentCount = 4; // Number of diagonal segments per period (/\/\)
        const diagonalLength = segmentLength / segmentCount; // 0.25
        const amplitude = diagonalLength; // 0.25 for 45-degree slopes and 90-degree corners

        // Generate zigzag points directly along the line length
        // Pattern: baseline(0) -> peak(1) -> baseline(2) -> valley(3) -> baseline(4) -> ...
        const points: [number, number, number][] = [];

        // Calculate total number of diagonal segments that fit
        const totalDiagonals = Math.ceil(lineLength / diagonalLength);

        // Generate points for each diagonal segment
        for (let i = 0; i <= totalDiagonals; i++) {
            const x = i * diagonalLength;

            // If we've exceeded the line length, interpolate the final point
            if (x > lineLength) {
                const prevX = (i - 1) * diagonalLength;
                const prevPhase = (i - 1) % 4;
                const currPhase = i % 4;

                // Get Z values for previous and current phase
                let prevZ = 0;
                if (prevPhase === 1) {
                    prevZ = amplitude;
                } else if (prevPhase === 3) {
                    prevZ = -amplitude;
                }

                let currZ = 0;
                if (currPhase === 1) {
                    currZ = amplitude;
                } else if (currPhase === 3) {
                    currZ = -amplitude;
                }

                // Interpolate to find Z at exact lineLength
                const t = (lineLength - prevX) / (x - prevX);
                const finalZ = prevZ + t * (currZ - prevZ);

                points.push([lineLength, 0, finalZ]);
                break;
            }

            const phase = i % 4;
            let z = 0;
            if (phase === 0) {
                z = 0; // Baseline
            } else if (phase === 1) {
                z = amplitude; // Peak
            } else if (phase === 2) {
                z = 0; // Baseline
            } else if (phase === 3) {
                z = -amplitude; // Valley
            }

            points.push([x, 0, z]);
        }

        // Create quad strip with thickness
        for (const [px, py, pz] of points) {
            positions.push(px, py, pz - thickness); // Bottom
            positions.push(px, py, pz + thickness); // Top
        }

        // Create triangle indices for quad strip
        for (let i = 0; i < points.length - 1; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create continuous sinewave geometry for the full line length (ZERO spacing)
     * Generates a seamless sinewave pattern along the entire X axis
     * @param lineLength - Total length of the line
     * @returns VertexData with positions and indices for continuous quad strip
     */
    static createContinuousSinewave(lineLength: number): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];

        const amplitude = 0.3;
        const periods = 0.5; // Half period per unit length
        const thickness = amplitude * 1.0; // Same as amplitude for visibility
        const segments = Math.max(20, Math.ceil(lineLength * 10)); // More segments for longer lines

        // Generate sine wave vertices
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = t * lineLength;
            const z = amplitude * Math.sin(2 * Math.PI * periods * lineLength * t);

            positions.push(x, 0, z - thickness); // Bottom
            positions.push(x, 0, z + thickness); // Top
        }

        // Create triangle indices for quad strip
        for (let i = 0; i < segments; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create zigzag segment geometry in XZ plane (Y=0)
     * Creates a quad strip following a zigzag pattern for seamless connection
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     * @param segmentLength - Length of one segment (X-direction), default 1.0
     * @param amplitude - Perpendicular amplitude (Z-direction peak height), default 0.5
     * @param thickness - Line thickness (quad strip width), default 0.05
     * @returns VertexData with positions and indices for quad strip
     */
    private static createZigzagSegmentGeometry(segmentLength = 1.0, amplitude = 0.5, thickness = 0.05): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];

        // Create a true zigzag pattern with diagonal slanting lines
        // For 90-degree corners with equal segment lengths, use 45-degree diagonals
        // This means: rise = run, so amplitude/2 = segmentLength/4
        // Or equivalently: amplitude = segmentLength/2
        const segmentCount = 4; // Number of diagonal segments per period (/\/\)
        const diagonalLength = segmentLength / segmentCount; // X-length per diagonal
        const segmentAmplitude = amplitude; // Z-height (perpendicular amplitude)

        // Zigzag points: continuous diagonal pattern /\/\/\ (XZ plane, Y=0)
        // Total Z extent: -0.5 to +0.5 = 1.0 (matches getGeometryDiameter)
        const points: [number, number, number][] = [
            [0, 0, 0], // Start at baseline
            [diagonalLength, 0, segmentAmplitude], // Up-right diagonal (/) to peak
            [2 * diagonalLength, 0, 0], // Down-right diagonal (\) back to baseline
            [3 * diagonalLength, 0, -segmentAmplitude], // Down-right diagonal (\) to valley
            [4 * diagonalLength, 0, 0], // Up-right diagonal (/) back to baseline - seamless tiling
        ];

        // Create quad strip with thickness
        for (const [x, y, z] of points) {
            positions.push(x, y, z - thickness); // Bottom
            positions.push(x, y, z + thickness); // Top
        }

        // Create triangle indices
        for (let i = 0; i < points.length - 1; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Get geometry perpendicular diameter for a pattern
     * Returns the actual mesh extent perpendicular to the line (the visual height)
     *
     * IMPORTANT: Returns the actual geometric extent (max - min), NOT 2 × radius
     * @param pattern - Pattern type
     * @param shapeType - Optional specific shape type (for alternating patterns)
     * @returns The perpendicular diameter of the geometry
     */
    static getGeometryDiameter(
        pattern: PatternType,
        shapeType?: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): number {
        // Get pattern definition to look up aspectRatio
        const patternDef = PATTERN_DEFINITIONS[pattern];

        // Determine which shape we're using
        const shape = shapeType ?? this.getDefaultShapeType(pattern);

        // Find the shape definition to get aspectRatio
        const shapeDef = patternDef.shapes.find((s) => s.type === shape) ?? patternDef.shapes[0];
        const aspectRatio = shapeDef.aspectRatio ?? 1.0;

        switch (shape) {
            case "circle":
            case "star":
                // Circle: radius=0.5 → extent from -0.5 to +0.5 = 1.0
                // Star: outerRadius=1.0, innerRadius=0.4 → extent from -1.0 to +1.0 = 2.0
                // But we use the ACTUAL geometric extent in createCircleGeometry (radius=0.5) and createStarGeometry (outerRadius=1.0)
                // Fixed: Circle geometry uses Math.cos/sin(angle) * 1.0, so extent is 2.0
                // But createCircleGeometry in PatternedLineRenderer uses radius=1.0 for unit circle
                // Actual extent is from -1.0 to +1.0 = 2.0
                return 2.0;
            case "box":
                // Box has length=1.0, width=1.0/aspectRatio
                // Perpendicular dimension (width) = 1.0 / aspectRatio
                return 1.0 / aspectRatio;
            case "diamond":
            case "sinewave-segment":
                // These have diameter=1.0
                return 1.0;
            case "zigzag-segment":
                // Zigzag with 90-degree corners: amplitude=0.25, diameter=0.5
                return 0.5;
            default:
                return 1.0;
        }
    }

    /**
     * Get the default shape type for a pattern
     * @param pattern - The pattern type
     * @returns The default shape type for the pattern
     */
    private static getDefaultShapeType(
        pattern: PatternType,
    ): "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment" {
        switch (pattern) {
            case "dot":
                return "circle";
            case "star":
                return "star";
            case "box":
            case "dash":
                return "box";
            case "diamond":
                return "diamond";
            case "dash-dot":
                return "box"; // First shape in alternating pattern
            case "sinewave":
                return "sinewave-segment";
            case "zigzag":
                return "zigzag-segment";
            default:
                return "circle";
        }
    }

    /**
     * Register camera position update callback
     * Updates all pattern materials in one batch per frame
     * @param scene - Babylon.js scene
     */
    private static registerCameraCallback(scene: Scene): void {
        if (this.cameraCallbackRegistered) {
            return;
        }

        this.cameraCallbackRegistered = true;

        scene.onBeforeRenderObservable.add(() => {
            const camera = scene.activeCamera;
            if (!camera) {
                return;
            }

            const cameraPos = camera.globalPosition;

            // Update all active materials in one batch
            for (const material of this.activeMaterials) {
                try {
                    material.setVector3("cameraPosition", cameraPos);
                    // lineDirection is set per PatternedLineMesh, not here
                } catch {
                    // Material was disposed, remove from set
                    this.activeMaterials.delete(material);
                }
            }
        });
    }
}
