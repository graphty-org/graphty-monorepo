/**
 * THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE.
 * INSTEAD EDIT the implementation plan in design/mesh-based-patterned-lines.md
 *
 * PatternedLineRenderer - Creates mesh-based patterns for line visualization
 *
 * Architecture:
 * - Static utility class for creating pattern geometries
 * - ALL geometries MUST use XZ plane (Y=0) for proper billboarding
 * - Uses FilledArrowRenderer shader for tangent billboarding
 * - Batched camera updates for performance
 *
 * @remarks
 * This implements Phases 1-4 of mesh-based-patterned-lines.md
 * - Phase 1: Discrete patterns (dot, star, dash, diamond) with billboarding
 * - Phase 2: Adaptive density (add/remove meshes based on line length)
 * - Phase 3: Alternating patterns (dash-dot)
 * - Phase 4: Connected patterns (sinewave, zigzag) with seamless connection
 */

import {
    Mesh,
    Scene,
    ShaderMaterial,
    Vector3,
    VertexData,
} from "@babylonjs/core";

import {FilledArrowRenderer} from "./FilledArrowRenderer";
import {PatternedLineMesh} from "./PatternedLineMesh";

/**
 * Wrapper for continuous pattern meshes (zigzag, sinewave)
 * Provides update() method interface compatible with Edge.transformEdgeMesh()
 */
export class ContinuousPatternMesh {
    mesh: Mesh;
    pattern: string;
    width: number;
    color: string;
    opacity: number;
    scene: Scene;
    lastLength = 0;
    isPickable = false;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    metadata: any = {};

    constructor(
        mesh: Mesh,
        pattern: string,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
    ) {
        this.mesh = mesh;
        this.pattern = pattern;
        this.width = width;
        this.color = color;
        this.opacity = opacity;
        this.scene = scene;
    }

    update(start: Vector3, end: Vector3): void {
        const direction = end.subtract(start);
        const lineLength = direction.length();
        const normalizedDir = direction.normalize();

        // Recreate geometry if length changed significantly (more than 1%)
        if (Math.abs(lineLength - this.lastLength) > lineLength * 0.01) {
            this.lastLength = lineLength;

            // Calculate shader scaling factor (same as createContinuousMesh)
            const geometryDiameter = PatternedLineRenderer["getGeometryDiameter"](this.pattern);
            const size = this.width / geometryDiameter;

            // Account for shader scaling: create geometry at 1/size of actual length
            const geometryLength = lineLength / size;

            // Recreate the geometry
            const vertexData = this.pattern === "zigzag" ?
                PatternedLineRenderer["createContinuousZigzag"](geometryLength) :
                PatternedLineRenderer["createContinuousSinewave"](geometryLength);

            vertexData.applyToMesh(this.mesh, true); // true = updatable
        }

        // Update position and line direction
        this.mesh.position = start.clone();
        FilledArrowRenderer.setLineDirection(this.mesh, normalizedDir);
    }

    dispose(): void {
        this.mesh.dispose();
    }
}

// ==========================================
// PATTERN TYPE DEFINITIONS
// ==========================================

export type PatternType = "dot" | "star" | "box" | "dash" | "diamond" | "dash-dot" | "sinewave" | "zigzag";

interface ShapeDefinition {
    type: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment";
    size?: number; // Base size multiplier (default 1.0)
    aspectRatio?: number; // For elongated shapes (default 1.0)
    points?: number; // For star (default 5)
    angle?: number; // For zigzag (default 60)
    periods?: number; // For sinewave (default 0.5)
}

interface SpacingConfig {
    min: number; // Minimum spacing (below this, remove meshes)
    ideal: number; // Target spacing
    max: number; // Maximum spacing (above this, add meshes)
}

export interface PatternDefinition {
    shapes: ShapeDefinition[];
    spacing: SpacingConfig;
    connected: boolean;
}

// ==========================================
// PATTERN REGISTRY
// ==========================================

export const PATTERN_DEFINITIONS: Record<PatternType, PatternDefinition> = {
    "dot": {
        shapes: [{type: "circle", size: 1.0}],
        spacing: {min: 0.2, ideal: 0.5, max: 1.0},
        connected: false,
    },
    "star": {
        shapes: [{type: "star", size: 1.0, points: 5}],
        spacing: {min: 0.3, ideal: 0.6, max: 1.2},
        connected: false,
    },
    "box": {
        shapes: [{type: "box", size: 1.0, aspectRatio: 1.0}],
        spacing: {min: 0.2, ideal: 0.5, max: 1.0},
        connected: false,
    },
    "dash": {
        shapes: [{type: "box", size: 1.0, aspectRatio: 3.0}],
        spacing: {min: 0.2, ideal: 0.4, max: 0.8},
        connected: false,
    },
    "diamond": {
        shapes: [{type: "diamond", size: 1.0}],
        spacing: {min: 0.2, ideal: 0.5, max: 1.0},
        connected: false,
    },
    "dash-dot": {
        shapes: [
            {type: "box", size: 1.0, aspectRatio: 3.0},
            {type: "circle", size: 0.6},
        ],
        spacing: {min: 0.15, ideal: 0.3, max: 0.6},
        connected: false,
    },
    "sinewave": {
        shapes: [{type: "sinewave-segment", size: 1.0, periods: 0.5}],
        spacing: {min: 0, ideal: 0, max: 0},
        connected: true,
    },
    "zigzag": {
        shapes: [{type: "zigzag-segment", size: 1.0, angle: 60}],
        spacing: {min: 0, ideal: 0, max: 0},
        connected: true,
    },
};

// ==========================================
// RENDERER CLASS
// ==========================================

// eslint-disable-next-line @typescript-eslint/no-extraneous-class -- Utility class with static state for shader registration
export class PatternedLineRenderer {
    private static activeMaterials = new Set<ShaderMaterial>();
    private static cameraCallbackRegistered = false;

    /**
     * Create a PatternedLineMesh instance
     * Note: start/end are already adjusted by Edge.transformArrowCap() for node surfaces and arrows
     */
    static create(
        pattern: PatternType,
        start: Vector3,
        end: Vector3,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
    ): PatternedLineMesh | ContinuousPatternMesh {
        // Register camera callback for batched shader updates
        this.registerCameraCallback(scene);

        // For continuous patterns (zigzag, sinewave), create a single tiled mesh
        const patternDef = PATTERN_DEFINITIONS[pattern];
        if (patternDef.connected) {
            return this.createContinuousMesh(pattern, start, end, width, color, opacity, scene);
        }

        return new PatternedLineMesh(pattern, start, end, width, color, opacity, scene);
    }

    /**
     * Create a single continuous mesh by tiling the pattern geometry along the line
     * Used for connected patterns like zigzag and sinewave with ZERO spacing
     */
    static createContinuousMesh(
        pattern: PatternType,
        start: Vector3,
        end: Vector3,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
    ): ContinuousPatternMesh {
        const direction = end.subtract(start);
        const lineLength = direction.length();

        // Calculate shader scaling factor
        const geometryDiameter = this.getGeometryDiameter(pattern);
        const size = width / geometryDiameter;

        // Account for shader scaling: create geometry at 1/size of actual length
        // so when shader scales by size, it reaches the correct lineLength
        const geometryLength = lineLength / size;

        // For connected patterns, generate the geometry for the scaled length
        const vertexData = pattern === "zigzag" ?
            this.createContinuousZigzag(geometryLength) :
            this.createContinuousSinewave(geometryLength);

        // Create the mesh
        const mesh = new Mesh(`continuous-${pattern}`, scene);
        vertexData.applyToMesh(mesh);

        // Apply shader
        FilledArrowRenderer.applyShader(mesh, {size, color, opacity}, scene);

        // Position and orient the mesh along the line
        mesh.position = start.clone();
        const normalizedDir = direction.normalize();

        // Set line direction for billboarding shader
        FilledArrowRenderer.setLineDirection(mesh, normalizedDir);

        // Wrap in ContinuousPatternMesh for update() interface
        return new ContinuousPatternMesh(mesh, pattern, width, color, opacity, scene);
    }

    /**
     * Create a single pattern mesh with appropriate geometry and shader
     * Phase 3: Now accepts shapeType parameter for alternating patterns
     */
    static createPatternMesh(
        pattern: PatternType,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
        shapeType?: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): Mesh {
        // Get geometry for pattern type
        // Phase 3: Use shapeType if provided, otherwise derive from pattern
        const geometry = shapeType ?
            this.getGeometryForShapeType(shapeType) :
            this.getGeometryForPattern(pattern);

        // Create mesh from geometry
        const meshName = shapeType ? `pattern-${pattern}-${shapeType}` : `pattern-${pattern}`;
        const mesh = new Mesh(meshName, scene);
        geometry.applyToMesh(mesh);

        // Apply FilledArrowRenderer shader
        // Calculate shader size to achieve desired visual width (perpendicular to line)
        // For geometries with perpendicular diameter D, shader size = desiredWidth / D
        const geometryDiameter = this.getGeometryDiameter(pattern, shapeType);
        const size = width / geometryDiameter;

        FilledArrowRenderer.applyShader(mesh, {size, color, opacity}, scene);

        // Track material for batched updates
        const material = mesh.material as ShaderMaterial;
        this.activeMaterials.add(material);

        return mesh;
    }

    /**
     * Get geometry for a pattern type
     */
    private static getGeometryForPattern(pattern: PatternType): VertexData {
        switch (pattern) {
            case "dot":
                return this.createCircleGeometry();
            case "star":
                return this.createStarGeometry();
            case "box":
                return this.createBoxGeometry(1.0); // aspect ratio 1:1 (square)
            case "dash":
                return this.createBoxGeometry(3.0); // aspect ratio 3:1
            case "diamond":
                return this.createDiamondGeometry();
            case "dash-dot":
                // Phase 3: For dash-dot, default to box (first shape)
                // Actual alternation is handled via shapeType parameter in createPatternMesh
                return this.createBoxGeometry(3.0);
            case "sinewave":
                return this.createSinewaveSegmentGeometry();
            case "zigzag":
                return this.createZigzagSegmentGeometry();
            default:
                throw new Error(`Unsupported pattern type: ${pattern as string}`);
        }
    }

    /**
     * Get geometry for a specific shape type
     * Phase 3: Enables alternating patterns (e.g., dash-dot)
     */
    private static getGeometryForShapeType(
        shapeType: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): VertexData {
        switch (shapeType) {
            case "circle":
                return this.createCircleGeometry();
            case "star":
                return this.createStarGeometry();
            case "box":
                return this.createBoxGeometry(3.0);
            case "diamond":
                return this.createDiamondGeometry();
            case "sinewave-segment":
                return this.createSinewaveSegmentGeometry();
            case "zigzag-segment":
                return this.createZigzagSegmentGeometry();
            default:
                throw new Error(`Unsupported shape type: ${shapeType as string}`);
        }
    }

    // ==========================================
    // GEOMETRY GENERATORS
    // CRITICAL: ALL MUST USE XZ PLANE (Y=0)!
    // ==========================================

    /**
     * Create circle geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createCircleGeometry(segments = 32): VertexData {
        const positions: number[] = [0, 0, 0]; // Center
        const indices: number[] = [];

        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            // XZ plane (Y=0)
            positions.push(
                Math.cos(angle), // X
                0, // Y = 0
                Math.sin(angle), // Z
            );

            if (i < segments) {
                indices.push(0, i + 1, i + 2);
            }
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create star geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createStarGeometry(
        points = 5,
        innerRadius = 0.4,
        outerRadius = 1.0,
    ): VertexData {
        const positions: number[] = [0, 0, 0]; // Center
        const indices: number[] = [];
        const totalPoints = points * 2;

        for (let i = 0; i <= totalPoints; i++) {
            const angle = (i / totalPoints) * Math.PI * 2;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            // XZ plane (Y=0)
            positions.push(
                Math.cos(angle) * radius, // X
                0, // Y = 0
                Math.sin(angle) * radius, // Z
            );

            if (i < totalPoints) {
                indices.push(0, i + 1, i + 2);
            }
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create box geometry in XZ plane (Y=0)
     * Elongated rectangle for dashes
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createBoxGeometry(aspectRatio = 1.0): VertexData {
        const length = 1.0;
        const width = length / aspectRatio;
        const halfLength = length / 2;
        const halfWidth = width / 2;

        // XZ plane (Y=0), centered at origin, extends along +/- X
        const positions = [
            -halfLength,
            0,
            halfWidth, // Top-left
            halfLength,
            0,
            halfWidth, // Top-right
            halfLength,
            0,
            -halfWidth, // Bottom-right
            -halfLength,
            0,
            -halfWidth, // Bottom-left
        ];

        const indices = [
            0,
            1,
            2, // First triangle
            0,
            2,
            3, // Second triangle
        ];

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create diamond geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createDiamondGeometry(): VertexData {
        const length = 1.0;
        const width = 0.8;

        // XZ plane (Y=0)
        const positions = [
            0,
            0,
            0, // Front tip
            -length / 2,
            0,
            width / 2, // Top
            -length,
            0,
            0, // Back tip
            -length / 2,
            0,
            -width / 2, // Bottom
        ];

        const indices = [
            0,
            1,
            2, // Top half
            0,
            2,
            3, // Bottom half
        ];

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create sinewave segment geometry in XZ plane (Y=0)
     * Creates a quad strip following a sine wave for seamless connection
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     *
     * @param segmentLength - Length of one segment (default 1.0)
     * @param amplitude - Wave amplitude (default 0.3)
     * @param periods - Number of complete sine wave periods per segment (default 0.5)
     * @returns VertexData with positions and indices for quad strip
     */
    private static createSinewaveSegmentGeometry(
        segmentLength = 1.0,
        amplitude = 0.3,
        periods = 0.5,
    ): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];
        const segments = 20; // Smooth curve
        const thickness = amplitude * 0.2; // Line thickness

        // Generate sine wave vertices in XZ plane (Y=0)
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = t * segmentLength;
            const z = amplitude * Math.sin((2 * Math.PI * periods) * t);

            // Create quad strip (two vertices per segment for thickness)
            positions.push(x, 0, z - thickness); // Bottom
            positions.push(x, 0, z + thickness); // Top
        }

        // Create triangle indices for quad strip
        for (let i = 0; i < segments; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create continuous zigzag geometry for the full line length (ZERO spacing)
     * Generates a seamless zigzag pattern along the entire X axis
     *
     * @param lineLength - Total length of the line
     * @returns VertexData with positions and indices for continuous quad strip
     */
    private static createContinuousZigzag(lineLength: number): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];

        // Pattern configuration
        const segmentLength = 1.0; // Length of one complete /\/\ period
        const thickness = 0.5; // Line thickness perpendicular to the zigzag (same as amplitude for visibility)

        // Calculate diagonal segment length and amplitude
        const segmentCount = 4; // Number of diagonal segments per period (/\/\)
        const diagonalLength = segmentLength / segmentCount; // 0.25
        const amplitude = diagonalLength * 2; // 0.5 to get total diameter of 1.0

        // Generate zigzag points directly along the line length
        // Pattern: baseline(0) -> peak(1) -> baseline(2) -> valley(3) -> baseline(4) -> ...
        const points: [number, number, number][] = [];

        // Calculate total number of diagonal segments that fit
        const totalDiagonals = Math.ceil(lineLength / diagonalLength);

        // Generate points for each diagonal segment
        for (let i = 0; i <= totalDiagonals; i++) {
            const x = Math.min(i * diagonalLength, lineLength); // Clamp to lineLength
            const phase = i % 4; // Which part of the /\/\ pattern

            let z = 0;
            if (phase === 0) z = 0; // Baseline
            else if (phase === 1) z = amplitude; // Peak
            else if (phase === 2) z = 0; // Baseline
            else if (phase === 3) z = -amplitude; // Valley

            points.push([x, 0, z]);

            // Stop if we've reached the end
            if (x >= lineLength) break;
        }

        // Create quad strip with thickness
        for (const [px, py, pz] of points) {
            positions.push(px, py, pz - thickness); // Bottom
            positions.push(px, py, pz + thickness); // Top
        }

        // Create triangle indices for quad strip
        for (let i = 0; i < points.length - 1; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create continuous sinewave geometry for the full line length (ZERO spacing)
     * Generates a seamless sinewave pattern along the entire X axis
     *
     * @param lineLength - Total length of the line
     * @returns VertexData with positions and indices for continuous quad strip
     */
    private static createContinuousSinewave(lineLength: number): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];

        const amplitude = 0.3;
        const periods = 0.5; // Half period per unit length
        const thickness = amplitude * 1.0; // Same as amplitude for visibility
        const segments = Math.max(20, Math.ceil(lineLength * 10)); // More segments for longer lines

        // Generate sine wave vertices
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = t * lineLength;
            const z = amplitude * Math.sin((2 * Math.PI * periods * lineLength) * t);

            positions.push(x, 0, z - thickness); // Bottom
            positions.push(x, 0, z + thickness); // Top
        }

        // Create triangle indices for quad strip
        for (let i = 0; i < segments; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create zigzag segment geometry in XZ plane (Y=0)
     * Creates a quad strip following a zigzag pattern for seamless connection
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     *
     * @param segmentLength - Length of one segment (default 1.0)
     * @param amplitude - Wave amplitude (default 0.3)
     * @param angle - Zigzag angle in degrees (default 60)
     * @returns VertexData with positions and indices for quad strip
     */
    private static createZigzagSegmentGeometry(
        segmentLength = 1.0,
        amplitude = 0.3,
        angle = 60,
    ): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];
        const thickness = amplitude * 0.2;

        // Create a true zigzag pattern with diagonal slanting lines
        // A zigzag consists of alternating diagonal segments (up-right, down-right)
        // For 90-degree corners with equal segment lengths, use 45-degree diagonals

        // IMPORTANT: Perpendicular extent must be 1.0 to match getGeometryDiameter()
        // Total Z extent from -0.5 to +0.5 = 1.0 diameter
        // Each diagonal segment goes at 45° (equal X and Z travel)
        const segmentCount = 4; // Number of diagonal segments per period
        const diagonalLength = segmentLength / segmentCount; // 0.25
        const segmentAmplitude = diagonalLength * 2; // 0.5 to get total diameter of 1.0

        // Zigzag points: continuous diagonal pattern /\/\/\ (XZ plane, Y=0)
        // Total Z extent: -0.5 to +0.5 = 1.0 (matches getGeometryDiameter)
        const points: [number, number, number][] = [
            [0, 0, 0], // Start at baseline
            [diagonalLength, 0, segmentAmplitude], // Up-right diagonal (/) to peak
            [2 * diagonalLength, 0, 0], // Down-right diagonal (\) back to baseline
            [3 * diagonalLength, 0, -segmentAmplitude], // Down-right diagonal (\) to valley
            [4 * diagonalLength, 0, 0], // Up-right diagonal (/) back to baseline - seamless tiling
        ];

        // Create quad strip with thickness
        for (const [x, y, z] of points) {
            positions.push(x, y, z - thickness); // Bottom
            positions.push(x, y, z + thickness); // Top
        }

        // Create triangle indices
        for (let i = 0; i < points.length - 1; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Get geometry perpendicular diameter for a pattern
     * Returns the actual mesh extent perpendicular to the line (the visual height)
     *
     * IMPORTANT: Returns the actual geometric extent (max - min), NOT 2 × radius
     *
     * @param pattern Pattern type
     * @param shapeType Optional specific shape type (for alternating patterns)
     */
    private static getGeometryDiameter(
        pattern: PatternType,
        shapeType?: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): number {
        // Get pattern definition to look up aspectRatio
        const patternDef = PATTERN_DEFINITIONS[pattern];

        // Determine which shape we're using
        const shape = shapeType ?? this.getDefaultShapeType(pattern);

        // Find the shape definition to get aspectRatio
        const shapeDef = patternDef.shapes.find(s => s.type === shape) ?? patternDef.shapes[0];
        const aspectRatio = shapeDef.aspectRatio ?? 1.0;

        switch (shape) {
            case "circle":
            case "star":
                // Circle: radius=0.5 → extent from -0.5 to +0.5 = 1.0
                // Star: outerRadius=1.0, innerRadius=0.4 → extent from -1.0 to +1.0 = 2.0
                // But we use the ACTUAL geometric extent in createCircleGeometry (radius=0.5) and createStarGeometry (outerRadius=1.0)
                // Fixed: Circle geometry uses Math.cos/sin(angle) * 1.0, so extent is 2.0
                // But createCircleGeometry in PatternedLineRenderer uses radius=1.0 for unit circle
                // Actual extent is from -1.0 to +1.0 = 2.0
                return 2.0;
            case "box":
                // Box has length=1.0, width=1.0/aspectRatio
                // Perpendicular dimension (width) = 1.0 / aspectRatio
                return 1.0 / aspectRatio;
            case "diamond":
            case "sinewave-segment":
            case "zigzag-segment":
                // These have diameter=1.0
                return 1.0;
            default:
                return 1.0;
        }
    }

    /**
     * Get the default shape type for a pattern
     */
    private static getDefaultShapeType(
        pattern: PatternType,
    ): "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment" {
        switch (pattern) {
            case "dot":
                return "circle";
            case "star":
                return "star";
            case "box":
            case "dash":
                return "box";
            case "diamond":
                return "diamond";
            case "dash-dot":
                return "box"; // First shape in alternating pattern
            case "sinewave":
                return "sinewave-segment";
            case "zigzag":
                return "zigzag-segment";
            default:
                return "circle";
        }
    }

    /**
     * Register camera position update callback
     * Updates all pattern materials in one batch per frame
     */
    private static registerCameraCallback(scene: Scene): void {
        if (this.cameraCallbackRegistered) {
            return;
        }

        this.cameraCallbackRegistered = true;

        scene.onBeforeRenderObservable.add(() => {
            const camera = scene.activeCamera;
            if (!camera) {
                return;
            }

            const cameraPos = camera.globalPosition;

            // Update all active materials in one batch
            for (const material of this.activeMaterials) {
                try {
                    material.setVector3("cameraPosition", cameraPos);
                    // lineDirection is set per PatternedLineMesh, not here
                } catch {
                    // Material was disposed, remove from set
                    this.activeMaterials.delete(material);
                }
            }
        });
    }
}
