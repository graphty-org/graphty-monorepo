/**
 * THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE.
 * INSTEAD EDIT the implementation plan in design/mesh-based-patterned-lines.md
 *
 * PatternedLineRenderer - Creates mesh-based patterns for line visualization
 *
 * Architecture:
 * - Static utility class for creating pattern geometries
 * - ALL geometries MUST use XZ plane (Y=0) for proper billboarding
 * - Uses FilledArrowRenderer shader for tangent billboarding
 * - Batched camera updates for performance
 *
 * @remarks
 * This implements Phases 1-4 of mesh-based-patterned-lines.md
 * - Phase 1: Discrete patterns (dot, star, dash, diamond) with billboarding
 * - Phase 2: Adaptive density (add/remove meshes based on line length)
 * - Phase 3: Alternating patterns (dash-dot)
 * - Phase 4: Connected patterns (sinewave, zigzag) with seamless connection
 */

import {
    Mesh,
    Scene,
    ShaderMaterial,
    Vector3,
    VertexData,
} from "@babylonjs/core";

import {FilledArrowRenderer} from "./FilledArrowRenderer";
import {PatternedLineMesh} from "./PatternedLineMesh";

// ==========================================
// PATTERN TYPE DEFINITIONS
// ==========================================

export type PatternType = "dot" | "star" | "box" | "dash" | "diamond" | "dash-dot" | "sinewave" | "zigzag";

interface ShapeDefinition {
    type: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment";
    size?: number; // Base size multiplier (default 1.0)
    aspectRatio?: number; // For elongated shapes (default 1.0)
    points?: number; // For star (default 5)
    angle?: number; // For zigzag (default 60)
    periods?: number; // For sinewave (default 0.5)
}

interface SpacingConfig {
    min: number; // Minimum spacing (below this, remove meshes)
    ideal: number; // Target spacing
    max: number; // Maximum spacing (above this, add meshes)
}

export interface PatternDefinition {
    shapes: ShapeDefinition[];
    spacing: SpacingConfig;
    connected: boolean;
}

// ==========================================
// PATTERN REGISTRY
// ==========================================

export const PATTERN_DEFINITIONS: Record<PatternType, PatternDefinition> = {
    "dot": {
        shapes: [{type: "circle", size: 1.0}],
        spacing: {min: 0.2, ideal: 0.5, max: 1.0},
        connected: false,
    },
    "star": {
        shapes: [{type: "star", size: 1.0, points: 5}],
        spacing: {min: 0.3, ideal: 0.6, max: 1.2},
        connected: false,
    },
    "box": {
        shapes: [{type: "box", size: 1.0, aspectRatio: 1.0}],
        spacing: {min: 0.2, ideal: 0.5, max: 1.0},
        connected: false,
    },
    "dash": {
        shapes: [{type: "box", size: 1.0, aspectRatio: 3.0}],
        spacing: {min: 0.2, ideal: 0.4, max: 0.8},
        connected: false,
    },
    "diamond": {
        shapes: [{type: "diamond", size: 1.0}],
        spacing: {min: 0.2, ideal: 0.5, max: 1.0},
        connected: false,
    },
    "dash-dot": {
        shapes: [
            {type: "box", size: 1.0, aspectRatio: 3.0},
            {type: "circle", size: 0.6},
        ],
        spacing: {min: 0.15, ideal: 0.3, max: 0.6},
        connected: false,
    },
    "sinewave": {
        shapes: [{type: "sinewave-segment", size: 1.0, periods: 0.5}],
        spacing: {min: 0, ideal: 0, max: 0},
        connected: true,
    },
    "zigzag": {
        shapes: [{type: "zigzag-segment", size: 1.0, angle: 60}],
        spacing: {min: 0, ideal: 0, max: 0},
        connected: true,
    },
};

// ==========================================
// RENDERER CLASS
// ==========================================

// eslint-disable-next-line @typescript-eslint/no-extraneous-class -- Utility class with static state for shader registration
export class PatternedLineRenderer {
    private static activeMaterials = new Set<ShaderMaterial>();
    private static cameraCallbackRegistered = false;

    /**
     * Create a PatternedLineMesh instance
     * Note: start/end are already adjusted by Edge.transformArrowCap() for node surfaces and arrows
     */
    static create(
        pattern: PatternType,
        start: Vector3,
        end: Vector3,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
    ): PatternedLineMesh {
        // Register camera callback for batched shader updates
        this.registerCameraCallback(scene);

        return new PatternedLineMesh(pattern, start, end, width, color, opacity, scene);
    }

    /**
     * Create a single pattern mesh with appropriate geometry and shader
     * Phase 3: Now accepts shapeType parameter for alternating patterns
     */
    static createPatternMesh(
        pattern: PatternType,
        width: number,
        color: string,
        opacity: number,
        scene: Scene,
        shapeType?: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): Mesh {
        // Get geometry for pattern type
        // Phase 3: Use shapeType if provided, otherwise derive from pattern
        const geometry = shapeType ?
            this.getGeometryForShapeType(shapeType) :
            this.getGeometryForPattern(pattern);

        // Create mesh from geometry
        const meshName = shapeType ? `pattern-${pattern}-${shapeType}` : `pattern-${pattern}`;
        const mesh = new Mesh(meshName, scene);
        geometry.applyToMesh(mesh);

        // Apply FilledArrowRenderer shader
        // Calculate shader size to achieve desired visual width (perpendicular to line)
        // For geometries with perpendicular diameter D, shader size = desiredWidth / D
        const geometryDiameter = this.getGeometryDiameter(pattern, shapeType);
        const size = width / geometryDiameter;
        FilledArrowRenderer.applyShader(mesh, {size, color, opacity}, scene);

        // Track material for batched updates
        const material = mesh.material as ShaderMaterial;
        this.activeMaterials.add(material);

        return mesh;
    }

    /**
     * Get geometry for a pattern type
     */
    private static getGeometryForPattern(pattern: PatternType): VertexData {
        switch (pattern) {
            case "dot":
                return this.createCircleGeometry();
            case "star":
                return this.createStarGeometry();
            case "box":
                return this.createBoxGeometry(1.0); // aspect ratio 1:1 (square)
            case "dash":
                return this.createBoxGeometry(3.0); // aspect ratio 3:1
            case "diamond":
                return this.createDiamondGeometry();
            case "dash-dot":
                // Phase 3: For dash-dot, default to box (first shape)
                // Actual alternation is handled via shapeType parameter in createPatternMesh
                return this.createBoxGeometry(3.0);
            case "sinewave":
                return this.createSinewaveSegmentGeometry();
            case "zigzag":
                return this.createZigzagSegmentGeometry();
            default:
                throw new Error(`Unsupported pattern type: ${pattern as string}`);
        }
    }

    /**
     * Get geometry for a specific shape type
     * Phase 3: Enables alternating patterns (e.g., dash-dot)
     */
    private static getGeometryForShapeType(
        shapeType: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): VertexData {
        switch (shapeType) {
            case "circle":
                return this.createCircleGeometry();
            case "star":
                return this.createStarGeometry();
            case "box":
                return this.createBoxGeometry(3.0);
            case "diamond":
                return this.createDiamondGeometry();
            case "sinewave-segment":
                return this.createSinewaveSegmentGeometry();
            case "zigzag-segment":
                return this.createZigzagSegmentGeometry();
            default:
                throw new Error(`Unsupported shape type: ${shapeType as string}`);
        }
    }

    // ==========================================
    // GEOMETRY GENERATORS
    // CRITICAL: ALL MUST USE XZ PLANE (Y=0)!
    // ==========================================

    /**
     * Create circle geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createCircleGeometry(segments = 32): VertexData {
        const positions: number[] = [0, 0, 0]; // Center
        const indices: number[] = [];

        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            // XZ plane (Y=0)
            positions.push(
                Math.cos(angle), // X
                0, // Y = 0
                Math.sin(angle), // Z
            );

            if (i < segments) {
                indices.push(0, i + 1, i + 2);
            }
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create star geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createStarGeometry(
        points = 5,
        innerRadius = 0.4,
        outerRadius = 1.0,
    ): VertexData {
        const positions: number[] = [0, 0, 0]; // Center
        const indices: number[] = [];
        const totalPoints = points * 2;

        for (let i = 0; i <= totalPoints; i++) {
            const angle = (i / totalPoints) * Math.PI * 2;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            // XZ plane (Y=0)
            positions.push(
                Math.cos(angle) * radius, // X
                0, // Y = 0
                Math.sin(angle) * radius, // Z
            );

            if (i < totalPoints) {
                indices.push(0, i + 1, i + 2);
            }
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create box geometry in XZ plane (Y=0)
     * Elongated rectangle for dashes
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createBoxGeometry(aspectRatio = 1.0): VertexData {
        const length = 1.0;
        const width = length / aspectRatio;
        const halfLength = length / 2;
        const halfWidth = width / 2;

        // XZ plane (Y=0), centered at origin, extends along +/- X
        const positions = [
            -halfLength,
            0,
            halfWidth, // Top-left
            halfLength,
            0,
            halfWidth, // Top-right
            halfLength,
            0,
            -halfWidth, // Bottom-right
            -halfLength,
            0,
            -halfWidth, // Bottom-left
        ];

        const indices = [
            0,
            1,
            2, // First triangle
            0,
            2,
            3, // Second triangle
        ];

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create diamond geometry in XZ plane (Y=0)
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     */
    private static createDiamondGeometry(): VertexData {
        const length = 1.0;
        const width = 0.8;

        // XZ plane (Y=0)
        const positions = [
            0,
            0,
            0, // Front tip
            -length / 2,
            0,
            width / 2, // Top
            -length,
            0,
            0, // Back tip
            -length / 2,
            0,
            -width / 2, // Bottom
        ];

        const indices = [
            0,
            1,
            2, // Top half
            0,
            2,
            3, // Bottom half
        ];

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create sinewave segment geometry in XZ plane (Y=0)
     * Creates a quad strip following a sine wave for seamless connection
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     *
     * @param segmentLength - Length of one segment (default 1.0)
     * @param amplitude - Wave amplitude (default 0.3)
     * @param periods - Number of complete sine wave periods per segment (default 0.5)
     * @returns VertexData with positions and indices for quad strip
     */
    private static createSinewaveSegmentGeometry(
        segmentLength = 1.0,
        amplitude = 0.3,
        periods = 0.5,
    ): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];
        const segments = 20; // Smooth curve
        const thickness = amplitude * 0.2; // Line thickness

        // Generate sine wave vertices in XZ plane (Y=0)
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = t * segmentLength;
            const z = amplitude * Math.sin((2 * Math.PI * periods) * t);

            // Create quad strip (two vertices per segment for thickness)
            positions.push(x, 0, z - thickness); // Bottom
            positions.push(x, 0, z + thickness); // Top
        }

        // Create triangle indices for quad strip
        for (let i = 0; i < segments; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Create zigzag segment geometry in XZ plane (Y=0)
     * Creates a quad strip following a zigzag pattern for seamless connection
     * Face normal points in ±Y direction, maps to shader's "up" vector (toward camera)
     *
     * @param segmentLength - Length of one segment (default 1.0)
     * @param amplitude - Wave amplitude (default 0.3)
     * @param angle - Zigzag angle in degrees (default 60)
     * @returns VertexData with positions and indices for quad strip
     */
    private static createZigzagSegmentGeometry(
        segmentLength = 1.0,
        amplitude = 0.3,
        angle = 60,
    ): VertexData {
        const positions: number[] = [];
        const indices: number[] = [];
        const thickness = amplitude * 0.2;

        // Calculate peak height from angle
        const peakHeight = Math.tan((angle * Math.PI) / 180) * (segmentLength / 2);

        // Zigzag points: 0 → peak → 0 → valley → 0 (XZ plane, Y=0)
        const points: [number, number, number][] = [
            [
                0,
                0,
                0,
            ], // Start
            [
                segmentLength / 4,
                0,
                peakHeight,
            ], // Peak
            [
                segmentLength / 2,
                0,
                0,
            ], // Mid
            [
                (3 * segmentLength) / 4,
                0,
                -peakHeight,
            ], // Valley
            [
                segmentLength,
                0,
                0,
            ], // End
        ];

        // Create quad strip with thickness
        for (const [x, y, z] of points) {
            positions.push(x, y, z - thickness); // Bottom
            positions.push(x, y, z + thickness); // Top
        }

        // Create triangle indices
        for (let i = 0; i < points.length - 1; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }

        const vertexData = new VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        return vertexData;
    }

    /**
     * Get geometry perpendicular diameter for a pattern
     * Returns the diameter perpendicular to the line (the visual height)
     *
     * @param pattern Pattern type
     * @param shapeType Optional specific shape type (for alternating patterns)
     */
    private static getGeometryDiameter(
        pattern: PatternType,
        shapeType?: "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment",
    ): number {
        // Get pattern definition to look up aspectRatio
        const patternDef = PATTERN_DEFINITIONS[pattern];

        // Determine which shape we're using
        const shape = shapeType ?? this.getDefaultShapeType(pattern);

        // Find the shape definition to get aspectRatio
        const shapeDef = patternDef.shapes.find(s => s.type === shape) ?? patternDef.shapes[0];
        const aspectRatio = shapeDef.aspectRatio ?? 1.0;

        switch (shape) {
            case "circle":
            case "star":
                // Circle and star have outerRadius=1.0 → diameter=2.0 (circular, so aspectRatio doesn't apply)
                return 2.0;
            case "box":
                // Box has length=1.0, width=1.0/aspectRatio
                // Perpendicular dimension (width) = 1.0 / aspectRatio
                return 1.0 / aspectRatio;
            case "diamond":
            case "sinewave-segment":
            case "zigzag-segment":
                // These have diameter=1.0
                return 1.0;
            default:
                return 1.0;
        }
    }

    /**
     * Get the default shape type for a pattern
     */
    private static getDefaultShapeType(
        pattern: PatternType,
    ): "circle" | "star" | "box" | "diamond" | "sinewave-segment" | "zigzag-segment" {
        switch (pattern) {
            case "dot":
                return "circle";
            case "star":
                return "star";
            case "box":
            case "dash":
                return "box";
            case "diamond":
                return "diamond";
            case "dash-dot":
                return "box"; // First shape in alternating pattern
            case "sinewave":
                return "sinewave-segment";
            case "zigzag":
                return "zigzag-segment";
            default:
                return "circle";
        }
    }

    /**
     * Register camera position update callback
     * Updates all pattern materials in one batch per frame
     */
    private static registerCameraCallback(scene: Scene): void {
        if (this.cameraCallbackRegistered) {
            return;
        }

        this.cameraCallbackRegistered = true;

        scene.onBeforeRenderObservable.add(() => {
            const camera = scene.activeCamera;
            if (!camera) {
                return;
            }

            const cameraPos = camera.globalPosition;

            // Update all active materials in one batch
            for (const material of this.activeMaterials) {
                try {
                    material.setVector3("cameraPosition", cameraPos);
                    // lineDirection is set per PatternedLineMesh, not here
                } catch {
                    // Material was disposed, remove from set
                    this.activeMaterials.delete(material);
                }
            }
        });
    }
}
