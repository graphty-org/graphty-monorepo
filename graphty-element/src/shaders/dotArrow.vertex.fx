// THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE. INSTEAD EDIT src/meshes/EdgeMesh.ts where shaders are defined
precision highp float;

// Attributes
attribute vec3 position;      // Quad corners: values from -1 to +1
attribute vec2 uv;            // UV coordinates for fragment shader

// Uniforms
uniform mat4 viewProjection;
uniform mat4 worldMatrix;
uniform mat4 projection;
uniform vec3 arrowCenter;     // World position of arrow center
uniform vec3 edgeDirection;   // Normalized direction from src to dst (world space)
uniform float arrowRadius;    // Radius in world units
uniform vec2 resolution;      // Screen resolution
uniform float aspect;         // Resolution aspect ratio

// Varyings
varying vec2 vUV;

// Helper function to convert clip space to screen space with aspect correction
// Based on GreasedLine's grlFix function
vec2 fix(vec4 clipPos, float aspectRatio) {
    vec2 screenPos = clipPos.xy / clipPos.w;
    screenPos.x *= aspectRatio;
    return screenPos;
}

void main() {
    vUV = uv;

    // Transform arrow center to clip space (same as GreasedLine does for line points)
    mat4 matrix = viewProjection * worldMatrix;
    vec4 centerClip = matrix * vec4(arrowCenter, 1.0);

    // Compute a point slightly ahead along edge direction for screen-space direction calculation
    vec3 nearPosition = arrowCenter + (edgeDirection * 0.01);
    vec4 nearClip = matrix * vec4(nearPosition, 1.0);

    // Convert to screen space with aspect correction (like GreasedLine's grlFix)
    vec2 centerScreen = fix(centerClip, aspect);
    vec2 nearScreen = fix(nearClip, aspect);

    // Compute screen-space direction of edge
    vec2 screenDir = normalize(nearScreen - centerScreen);

    // Compute perpendicular to edge in screen space (like GreasedLine's grlNormal)
    // Rotate 90 degrees: (x,y) -> (-y,x)
    vec2 perpendicular = vec2(-screenDir.y, screenDir.x);

    // Compute screen-space offset for this quad vertex
    // position.x and position.y are the quad corner offsets (-1 to +1)
    // Expand perpendicular to screenDir and along screenDir
    vec2 screenOffset = (perpendicular * position.x) + (screenDir * position.y);

    // Scale by arrow radius to get final screen-space offset
    screenOffset *= arrowRadius;

    // Convert screen-space offset to clip space (following GreasedLine's technique)
    vec4 offsetClip = vec4(screenOffset, 0.0, 0.0);
    offsetClip *= projection;
    offsetClip.xy *= centerClip.w; // Scale by w for proper perspective
    offsetClip.xy /= (vec4(resolution, 0.0, 1.0) * projection).xy;

    // Apply offset to center position
    gl_Position = centerClip + offsetClip;
}
