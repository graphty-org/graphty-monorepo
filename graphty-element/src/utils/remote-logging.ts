/* eslint-disable no-console -- Remote logging utility requires console access */
/**
 * Remote logging utility for XR debugging.
 * Sends console logs to a remote server for viewing on desktop.
 * THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE. See examples/xr/xr-demo-server.js for the server.
 */

interface LogEntry {
    time: string;
    level: string;
    message: string;
}

interface RemoteLoggingState {
    enabled: boolean;
    serverUrl: string;
    sessionId: string;
    logBuffer: LogEntry[];
    flushTimer: ReturnType<typeof setTimeout> | null;
    originalConsole: {
        log: typeof console.log;
        warn: typeof console.warn;
        error: typeof console.error;
        info: typeof console.info;
    } | null;
    lastMessages: Map<string, number>;
}

const state: RemoteLoggingState = {
    enabled: false,
    serverUrl: "",
    sessionId: "",
    logBuffer: [],
    flushTimer: null,
    originalConsole: null,
    lastMessages: new Map(),
};

// Patterns to throttle (prevents log flooding)
const THROTTLE_PATTERNS = [
    /Max number of touches/,
    /Max touches exceeded/,
];
const THROTTLE_MS = 5000;

function shouldThrottle(message: string): boolean {
    for (const pattern of THROTTLE_PATTERNS) {
        if (pattern.test(message)) {
            const key = pattern.source;
            const lastTime = state.lastMessages.get(key) ?? 0;
            const now = Date.now();
            if (now - lastTime < THROTTLE_MS) {
                return true;
            }

            state.lastMessages.set(key, now);
            return false;
        }
    }
    return false;
}

function flushLogs(): void {
    if (state.logBuffer.length === 0) {
        return;
    }

    const logsToSend = state.logBuffer.splice(0, state.logBuffer.length);

    fetch(state.serverUrl, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({sessionId: state.sessionId, logs: logsToSend}),
    }).catch(() => {
        // Put logs back on failure
        state.logBuffer.unshift(... logsToSend);
    });
}

function formatArgs(args: unknown[]): string {
    return args.map((arg) => {
        if (typeof arg === "object" && arg !== null) {
            try {
                return JSON.stringify(arg, null, 2);
            } catch {
                return "[Circular or non-serializable object]";
            }
        }

        return String(arg);
    }).join(" ");
}

function queueLog(level: string, args: unknown[]): void {
    if (!state.enabled) {
        return;
    }

    const message = formatArgs(args);

    if (shouldThrottle(message)) {
        return;
    }

    state.logBuffer.push({
        time: new Date().toISOString(),
        level,
        message,
    });

    if (state.flushTimer) {
        clearTimeout(state.flushTimer);
    }

    state.flushTimer = setTimeout(flushLogs, 100);
}

/**
 * Enable remote logging.
 * Hooks into console.log/warn/error/info and sends to the specified server.
 *
 * @param serverUrl - The URL to POST logs to (e.g., "https://localhost:9077/log")
 * @param sessionPrefix - Prefix for session ID (defaults to "graphty")
 */
export function enableRemoteLogging(serverUrl: string, sessionPrefix = "graphty"): void {
    if (state.enabled) {
        console.warn("[RemoteLogging] Already enabled, ignoring");
        return;
    }

    state.enabled = true;
    state.serverUrl = serverUrl;
    state.sessionId = `${sessionPrefix}-${Date.now().toString(36)}`;
    state.logBuffer = [];

    // Store original console methods
    state.originalConsole = {
        log: console.log.bind(console),
        warn: console.warn.bind(console),
        error: console.error.bind(console),
        info: console.info.bind(console),
    };

    // Override console methods
    console.log = (... args: unknown[]) => {
        state.originalConsole?.log(... args);
        queueLog("LOG", args);
    };
    console.warn = (... args: unknown[]) => {
        state.originalConsole?.warn(... args);
        queueLog("WARN", args);
    };
    console.error = (... args: unknown[]) => {
        state.originalConsole?.error(... args);
        queueLog("ERROR", args);
    };
    console.info = (... args: unknown[]) => {
        state.originalConsole?.info(... args);
        queueLog("INFO", args);
    };

    // Log that we started
    console.log(`[RemoteLogging] Enabled with session: ${state.sessionId}`);
}

/**
 * Disable remote logging.
 * Restores original console methods.
 */
export function disableRemoteLogging(): void {
    if (!state.enabled || !state.originalConsole) {
        return;
    }

    // Flush remaining logs
    flushLogs();

    // Restore original console
    console.log = state.originalConsole.log;
    console.warn = state.originalConsole.warn;
    console.error = state.originalConsole.error;
    console.info = state.originalConsole.info;

    state.enabled = false;
    state.originalConsole = null;
}

/**
 * Check if remote logging is enabled.
 */
export function isRemoteLoggingEnabled(): boolean {
    return state.enabled;
}
