/**
 * Mock Graph Context for AI testing.
 * THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE. INSTEAD EDIT THE TEST HELPERS.
 * @module test/helpers/mock-graph-context
 */

import type {Graph} from "../../src/Graph";
import type {DataManager} from "../../src/managers";

/**
 * Options for creating a mock graph context.
 */
export interface MockGraphContextOptions {
    /** Initial node count */
    nodeCount?: number;
    /** Initial edge count */
    edgeCount?: number;
    /** Current layout type */
    layoutType?: string;
    /** Whether the graph is in 2D mode */
    twoD?: boolean;
}

/**
 * Mock node data for testing.
 */
export interface MockNodeData {
    id: string;
    data: Record<string, unknown>;
    algorithmResults?: Record<string, unknown>;
}

/**
 * Mock edge data for testing.
 */
export interface MockEdgeData {
    id: string;
    srcId: string;
    dstId: string;
    data: Record<string, unknown>;
}

/**
 * Get node type from index.
 */
function getNodeType(index: number): string {
    if (index % 3 === 0) {
        return "server";
    }

    if (index % 3 === 1) {
        return "client";
    }

    return "router";
}

/**
 * Create a mock graph context for testing AI functionality.
 * This creates a minimal mock that satisfies the Graph interface for AI commands.
 *
 * @param options - Configuration options
 * @returns A mock graph context
 */
export function createMockGraphContext(options: MockGraphContextOptions = {}): Graph {
    const {
        nodeCount = 10,
        edgeCount = 15,
        layoutType = "ngraph",
        twoD = false,
    } = options;

    // Create mock nodes
    // Data structure uses {data: {type: ...}} format to match JMESPath selectors like "data.type == 'server'"
    const mockNodes = new Map<string, MockNodeData>();
    for (let i = 0; i < nodeCount; i++) {
        const id = `node-${i}`;
        mockNodes.set(id, {
            id,
            data: {
                id,
                label: `Node ${i}`,
                data: {
                    type: getNodeType(i),
                },
            },
        });
    }

    // Create mock edges
    const mockEdges = new Map<string, MockEdgeData>();
    const nodeIds = Array.from(mockNodes.keys());
    for (let i = 0; i < edgeCount; i++) {
        const id = `edge-${i}`;
        // Create edges connecting nodes in a round-robin fashion
        const srcIdx = i % nodeIds.length;
        const dstIdx = (i + 1) % nodeIds.length;
        mockEdges.set(id, {
            id,
            srcId: nodeIds[srcIdx],
            dstId: nodeIds[dstIdx],
            data: {id, weight: Math.random()},
        });
    }

    // Current layout type (mutable for testing layout changes)
    let currentLayoutType = layoutType;
    let currentTwoD = twoD;
    let currentLayoutEngine = {type: layoutType};

    // Track layout running state
    let layoutRunning = false;

    // XR helper mock
    let xrHelperMock: {
        enterVR: () => Promise<void>;
        enterAR: () => Promise<void>;
    } | null = null;

    // Create mock data manager
    const mockDataManager = {
        nodes: mockNodes,
        edges: mockEdges,
        getNode: (id: string | number) => mockNodes.get(String(id)),
        getEdge: (id: string) => mockEdges.get(id),
    } as unknown as DataManager;

    // Create mock layout manager
    const mockLayoutManager = {
        get layoutEngine() {
            return currentLayoutEngine;
        },
        get running() {
            return layoutRunning;
        },
        set running(value: boolean) {
            layoutRunning = value;
        },
        get isSettled() {
            return !layoutRunning;
        },
        setLayout(type: string): void {
            currentLayoutType = type;
            currentLayoutEngine = {type};
        },
        updateLayoutDimension(is2D: boolean): void {
            currentTwoD = is2D;
        },
    };

    // Create mock style layers array
    const mockStyleLayers: {
        node?: {selector: string, style: object};
        edge?: {selector: string, style: object};
        metadata?: {name: string};
    }[] = [];

    // Create mock styles config
    const mockStyles = {
        config: {
            graph: {
                get twoD() {
                    return currentTwoD;
                },
                get layout() {
                    return currentLayoutType;
                },
                addDefaultStyle: true,
                background: {
                    backgroundType: "color" as const,
                    color: "#F5F5F5",
                },
                startingCameraDistance: 100,
                layoutOptions: undefined,
            },
            data: {
                algorithms: [],
            },
            behavior: {},
        },
        layers: mockStyleLayers,
        addLayer(layer: typeof mockStyleLayers[0]): void {
            mockStyleLayers.push(layer);
        },
    };

    // Create mock style manager (wraps styles with cache/event handling)
    const mockStyleManager = {
        getStyles: () => mockStyles,
        addLayer(layer: typeof mockStyleLayers[0]): void {
            mockStyles.addLayer(layer);
            // In the real StyleManager, this also clears cache and emits style-changed event
        },
        insertLayer(position: number, layer: typeof mockStyleLayers[0]): void {
            mockStyleLayers.splice(position, 0, layer);
        },
        removeLayersByMetadata(predicate: (metadata: unknown) => boolean): void {
            // Filter out layers matching the predicate
            const originalLength = mockStyleLayers.length;
            for (let i = mockStyleLayers.length - 1; i >= 0; i--) {
                if (predicate(mockStyleLayers[i].metadata)) {
                    mockStyleLayers.splice(i, 1);
                }
            }

            void originalLength; // Suppress unused variable warning
        },
        clearCache: () => {
            // Mock implementation - no-op for testing
        },
    };

    // Create the mock graph object
    const mockGraph = {
        // Data access
        getNodeCount: () => mockNodes.size,
        getEdgeCount: () => mockEdges.size,
        getDataManager: () => mockDataManager,
        getLayoutManager: () => mockLayoutManager,
        getStyles: () => mockStyles,
        getStyleManager: () => mockStyleManager,

        // Layout methods
        setLayout(type: string): void {
            // Simulate error for unknown layout types
            const knownLayouts = [
                "circular",
                "ngraph",
                "random",
                "d3",
                "spiral",
                "shell",
                "spring",
                "planar",
                "kamada-kawai",
                "forceatlas2",
                "arf",
                "spectral",
                "bfs",
                "bipartite",
                "multipartite",
                "fixed",
            ];

            if (!knownLayouts.includes(type)) {
                throw new Error(`Unknown layout type: "${type}" not found`);
            }

            mockLayoutManager.setLayout(type);
        },

        // Style template method (returns Promise for compatibility with real Graph API)
        setStyleTemplate(template: {graph?: {twoD?: boolean}}): Promise<void> {
            // Update twoD mode if specified
            if (template.graph?.twoD !== undefined) {
                currentTwoD = template.graph.twoD;
            }

            return Promise.resolve();
        },

        // Style access
        styles: mockStyles,

        // Camera methods (mock)
        async setCameraState(
            state: {
                preset?: string;
                position?: {x: number, y: number, z: number};
                target?: {x: number, y: number, z: number};
            },
        ): Promise<void> {
            // Mock implementation - validates known presets
            const knownPresets = ["fitToGraph", "topView", "sideView", "frontView", "isometric"];
            if (state.preset && !knownPresets.includes(state.preset)) {
                throw new Error(`Unknown camera preset: "${state.preset}"`);
            }

            // Mock implementation accepts all valid presets and positions
            return Promise.resolve();
        },
        getCameraState: () => ({
            position: {x: 0, y: 10, z: 10},
            target: {x: 0, y: 0, z: 0},
        }),

        // Mode check
        is2D: () => currentTwoD,

        // XR methods
        getXRHelper: () => xrHelperMock,
        setXRHelper: (helper: typeof xrHelperMock) => {
            xrHelperMock = helper;
        },
        exitImmersiveMode(): void {
            // Mock implementation
        },

        // Event handling (mock)
        on: (): void => undefined,
        addListener: (): void => undefined,

        // Screenshot capture (mock)
        captureScreenshot() {
            return {
                blob: new Blob(["mock"], {type: "image/png"}),
                dataUrl: "data:image/png;base64,mock",
                metadata: {
                    width: 800,
                    height: 600,
                    format: "png" as const,
                    timestamp: Date.now(),
                },
            };
        },

        // For testing - ability to set mock XR helper
        __testSetXRHelper: (helper: typeof xrHelperMock) => {
            xrHelperMock = helper;
        },

        // Algorithm methods
        async runAlgorithm(namespace: string, type: string): Promise<void> {
            // Mock implementation - use parameters to avoid lint warnings
            void namespace;
            void type;
            return Promise.resolve();
        },
    } as unknown as Graph;

    return mockGraph;
}
