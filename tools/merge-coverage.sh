#!/bin/bash
# THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE
# Regenerate by editing the script logic if needed

# merge-coverage.sh - Merge coverage reports from all packages
#
# Usage:
#   ./tools/merge-coverage.sh                        # Merge existing coverage files
#   ./tools/merge-coverage.sh --ci                   # CI mode: fail if any package is missing coverage
#   ./tools/merge-coverage.sh --artifacts <dir>      # Use CI artifacts from download-artifact
#
# This script:
#   1. Collects coverage/lcov.info from each package (or from CI artifacts)
#   2. Rewrites paths to include package prefix (e.g., SF:src/foo.ts -> SF:algorithms/src/foo.ts)
#   3. Merges all lcov files using lcov-result-merger
#   4. Outputs summary statistics
#
# Expected input:
#   Each package should have coverage/lcov.info generated by running their coverage command

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
COVERAGE_DIR="$ROOT_DIR/.coverage-packages"
OUTPUT_FILE="$ROOT_DIR/coverage/lcov.info"

# Packages to process
PACKAGES=("algorithms" "layout" "graphty" "graphty-element")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Parse arguments
CI_MODE=false
ARTIFACTS_DIR=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --ci)
            CI_MODE=true
            shift
            ;;
        --artifacts)
            ARTIFACTS_DIR="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [--ci] [--artifacts <dir>]"
            echo ""
            echo "Options:"
            echo "  --ci               CI mode: fail if any package is missing coverage"
            echo "  --artifacts <dir>  Use CI artifacts directory (from actions/download-artifact)"
            echo "  --help             Show this help message"
            echo ""
            echo "Each package should have coverage/lcov.info generated before running this script."
            echo "Run package-specific coverage commands first:"
            echo "  cd algorithms && pnpm run coverage"
            echo "  cd layout && pnpm run coverage"
            echo "  cd graphty && pnpm run coverage"
            echo "  cd graphty-element && pnpm run coverage"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Create output directories
log_info "Preparing coverage directories..."
rm -rf "$COVERAGE_DIR"
mkdir -p "$COVERAGE_DIR"
mkdir -p "$(dirname "$OUTPUT_FILE")"

# Function to check if artifact name matches package
# Returns 0 (true) if matches, 1 (false) otherwise
artifact_matches_package() {
    local artifact_name=$1
    local pkg=$2

    # Exact match: coverage-algorithms, coverage-layout, coverage-graphty, coverage-graphty-element
    if [[ "$artifact_name" == "coverage-$pkg" ]]; then
        return 0
    fi

    # Shard match: coverage-{pkg}-{shard} but not coverage-graphty-element when pkg=graphty
    if [[ "$artifact_name" == "coverage-$pkg-"* ]]; then
        # Special case: don't match graphty-element shards when looking for graphty
        if [[ "$pkg" == "graphty" && "$artifact_name" == "coverage-graphty-element"* ]]; then
            return 1
        fi
        return 0
    fi

    return 1
}

# Function to collect coverage from CI artifacts
collect_from_artifacts() {
    local pkg=$1
    local output_file=$2

    # CI artifacts are named like: coverage-algorithms, coverage-layout, coverage-graphty,
    # coverage-graphty-element-default, coverage-graphty-element-browser-1, etc.
    local found_files=()

    # Find all matching artifact directories
    for dir in "$ARTIFACTS_DIR"/coverage-*; do
        if [ ! -d "$dir" ] || [ ! -f "$dir/lcov.info" ]; then
            continue
        fi

        local dirname=$(basename "$dir")
        if artifact_matches_package "$dirname" "$pkg"; then
            found_files+=("$dir/lcov.info")
        fi
    done

    if [ ${#found_files[@]} -eq 0 ]; then
        return 1
    elif [ ${#found_files[@]} -eq 1 ]; then
        # Single file, just rewrite paths
        sed "s|^SF:|SF:$pkg/|" "${found_files[0]}" > "$output_file"
    else
        # Multiple shards (graphty-element), merge them first then rewrite
        log_info "  Merging ${#found_files[@]} shards for $pkg..."

        # Create temp directory for shards and copy files there
        local temp_dir=$(mktemp -d)
        local i=1
        for f in "${found_files[@]}"; do
            cp "$f" "$temp_dir/shard-$i.info"
            ((i++)) || true
        done

        # Merge using glob pattern
        local temp_merged="$temp_dir/merged.info"
        if ! pnpm exec lcov-result-merger "$temp_dir/*.info" "$temp_merged" 2>/dev/null; then
            log_warn "  Failed to merge shards for $pkg, trying concatenation..."
            cat "$temp_dir"/*.info > "$temp_merged"
        fi

        # Rewrite paths
        if [ -f "$temp_merged" ]; then
            sed "s|^SF:|SF:$pkg/|" "$temp_merged" > "$output_file"
        else
            log_warn "  No merged file produced for $pkg"
            rm -rf "$temp_dir"
            return 1
        fi

        # Cleanup
        rm -rf "$temp_dir"
    fi
    return 0
}

# Collect and rewrite coverage files
log_info "Collecting coverage files..."
COLLECTED=0
MISSING=()

for pkg in "${PACKAGES[@]}"; do
    OUTPUT_LCOV="$COVERAGE_DIR/$pkg.info"

    if [ -n "$ARTIFACTS_DIR" ]; then
        # Collect from CI artifacts directory
        if collect_from_artifacts "$pkg" "$OUTPUT_LCOV"; then
            LINES=$(wc -l < "$OUTPUT_LCOV")
            log_success "$pkg: collected ($LINES lines)"
            COLLECTED=$((COLLECTED + 1))
        else
            log_warn "$pkg: no coverage artifacts found"
            MISSING+=("$pkg")
        fi
    else
        # Collect from package directory
        LCOV_FILE="$ROOT_DIR/$pkg/coverage/lcov.info"

        if [ -f "$LCOV_FILE" ]; then
            # Rewrite SF: paths to include package prefix
            sed "s|^SF:|SF:$pkg/|" "$LCOV_FILE" > "$OUTPUT_LCOV"

            # Get line count for verification
            LINES=$(wc -l < "$OUTPUT_LCOV")
            log_success "$pkg: collected ($LINES lines)"
            COLLECTED=$((COLLECTED + 1))
        else
            log_warn "$pkg: no coverage file found at $LCOV_FILE"
            MISSING+=("$pkg")
        fi
    fi
done

# Check if we have any coverage to merge
if [ $COLLECTED -eq 0 ]; then
    log_error "No coverage files found."
    log_error "Run coverage for each package first:"
    log_error "  cd algorithms && pnpm run coverage"
    log_error "  cd layout && pnpm run coverage"
    log_error "  cd graphty && pnpm run coverage"
    log_error "  cd graphty-element && pnpm run coverage"
    exit 1
fi

# In CI mode, fail if any packages are missing
if [ "$CI_MODE" = true ] && [ ${#MISSING[@]} -gt 0 ]; then
    log_error "CI mode: Missing coverage for packages: ${MISSING[*]}"
    exit 1
fi

# Merge coverage files
log_info "Merging coverage files..."
if pnpm exec lcov-result-merger "$COVERAGE_DIR/*.info" "$OUTPUT_FILE"; then
    MERGED_LINES=$(wc -l < "$OUTPUT_FILE")
    log_success "Merged coverage written to $OUTPUT_FILE ($MERGED_LINES lines)"
else
    log_error "Failed to merge coverage files"
    exit 1
fi

# Generate summary
echo ""
echo "========================================"
echo "       COVERAGE SUMMARY"
echo "========================================"
echo ""

TOTAL_LF=0
TOTAL_LH=0

for pkg in "${PACKAGES[@]}"; do
    LCOV_FILE="$COVERAGE_DIR/$pkg.info"
    if [ -f "$LCOV_FILE" ]; then
        # Sum LF (lines found) and LH (lines hit)
        LF=$(awk -F: '/^LF:/{sum+=$2}END{print sum+0}' "$LCOV_FILE")
        LH=$(awk -F: '/^LH:/{sum+=$2}END{print sum+0}' "$LCOV_FILE")

        if [ "$LF" -gt 0 ]; then
            PCT=$(awk "BEGIN {printf \"%.1f\", ($LH/$LF)*100}")
            printf "  %-20s %6d / %-6d (%s%%)\n" "$pkg:" "$LH" "$LF" "$PCT"
            TOTAL_LF=$((TOTAL_LF + LF))
            TOTAL_LH=$((TOTAL_LH + LH))
        else
            printf "  %-20s %s\n" "$pkg:" "no data"
        fi
    else
        printf "  %-20s %s\n" "$pkg:" "(missing)"
    fi
done

echo "  ----------------------------------------"
if [ "$TOTAL_LF" -gt 0 ]; then
    TOTAL_PCT=$(awk "BEGIN {printf \"%.1f\", ($TOTAL_LH/$TOTAL_LF)*100}")
    printf "  %-20s %6d / %-6d (%s%%)\n" "TOTAL:" "$TOTAL_LH" "$TOTAL_LF" "$TOTAL_PCT"
else
    printf "  %-20s %s\n" "TOTAL:" "no data"
fi
echo ""
echo "========================================"
echo ""

# Output location
log_info "Merged lcov file: $OUTPUT_FILE"
log_info "Individual reports: $COVERAGE_DIR/"

exit 0
